{
  "hash": "046152d33c34d34564ee047409e5643a",
  "result": {
    "engine": "knitr",
    "markdown": "# Introduction to R\n\nThe R programming language is a powerful tool for evolutionary biology research, offering a vast array of statistical and visualization tools that are essential for data analysis. With its extensive library of packages, R allows researchers to quickly and easily perform complex statistical analyses, including phylogenetic analyses, genome-wide association studies, and population genetics. R also provides a range of plotting and visualization functions that enable researchers to explore and present their data in a clear and concise manner. Additionally, R can be used in conjunction with other software tools, such as BEAST and IQ-TREE, to facilitate more complex evolutionary analyses. Due to its versatility and user-friendly interface, R has become an increasingly popular choice for evolutionary biologists looking to conduct high-quality research.\n\n## Goals of this lesson\n\nThis lesson was designed to be a gentle introduction to R for evolutionary genomics. Thus, we will only cover the basics of the language. An alternative name for this lesson could be *\"all you need to know about R to start your evolutionary analyses\"*. At the end of this lesson, you will be able to:\n\n-   perform simple mathematical operations in R\n-   create and modify objects\n-   use functions and look for help\n-   create vectors and understand the difference between vector types\n-   create data frames\n-   subset vectors and data frames\n\n## Creating objects\n\nThe simplest use of R is to perform mathematical operations, which can be simply typed in the console:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\n4 * 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n\n```{.r .cell-code}\n20 / 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\n5 - 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\nHowever, simple mathematical operations are not very useful. Typically, you would want to assign *values* to *R objects*. R objects can be created by using `object_name` + `<-` + `value`. The `<-` symbol is called the \"assignment operator\", and it assigns values to objects. Example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenome_size <- 2000000\n```\n:::\n\n\nNote that when you assign a value to an object, nothing happens on the screen. In the example above, we created an object named `genome_size` that contains the value `2000000`, but the value is not printed to screen. To show the contents of an object, you must type its name and execute it. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenome_size\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2e+06\n```\n\n\n:::\n:::\n\n\nAlternatively, we can assign values to objects *AND* print them at the same time by surrounding the assignment code with parentheses. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(genome_size <- 2000000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2e+06\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n### Naming objects\n\nAlthough you can give your objects whatever name you want, some general best practices include:\n\n1.  Choose a **descriptive** name, but **not too long**.\n2.  Do not use dots (`.`).\n3.  Use nouns.\n4.  Be consistent with your styling. Styles include **snake case** (e.g., `phylo_tree`) and **camel case** (e.g., `phyloTree`.)\n\nNote that object names **cannot start with numbers**.\n:::\n\nNow that we have an object `genome_size` with a value, we can use the object to perform mathematical operations. For example, let's suppose we want to see the genome size in many thousands of base pairs (i.e., kbp, which stands for kilobase pairs):\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenome_size / 1000\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2000\n```\n\n\n:::\n:::\n\n\nWe can also change the value of an object by assigning a new value to it. For instance, let's update the `genome_size` object with the size in kbp:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenome_size # original object\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2e+06\n```\n\n\n:::\n\n```{.r .cell-code}\ngenome_size <- genome_size / 1000 # modifying the object\ngenome_size\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2000\n```\n\n\n:::\n:::\n\n\nAs you can see, the object `genome_size` now contains the value `2000`.\n\n## Functions and arguments\n\nFunctions are scripts that automate a particular task, and they typically have verbs in their names. They are made available to users as part of *packages*, and there are several R packages with specialized functions for each field. When you download and install R, it already comes with some packages installed, such as **base** and **utils**, but you can also install other packages depending on your needs.\n\nA function takes one or many arguments as input and return something as output. To execute a function in R, you need to write the function name followed by the arguments inside parenthesis. For example, let's execute the function `sqrt()`, which takes a numeric value as input and return its square root:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(100)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\nYou can also pass objects as input to functions. For example, let's pass our object `genome_size` to the `sqrt()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(genome_size)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 44.72136\n```\n\n\n:::\n:::\n\n\nTo see all the possible arguments a function takes, use the function `args()` with the function name as input. For example, let's see all possible arguments for the `round()` function (which rounds up numbers):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(round)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, digits = 0) \nNULL\n```\n\n\n:::\n:::\n\n\nWe can see that the `round()` function can take two arguments as input: `x`, which is a numeric value, and `digits`, which indicates how many digits should be used when rounding values. Let's try to execute the `round()` function with different options to `digits`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npi <- 3.14159\nround(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nround(pi, digits = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.14\n```\n\n\n:::\n\n```{.r .cell-code}\nround(pi, digits = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.142\n```\n\n\n:::\n:::\n\n\nFinally, if you want to learn more about what a function does and how to use it, you can type the function name preceded by a question mark. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?round\n```\n:::\n\n\nThis will open up a help page with detailed information on what the function does, its arguments, and examples.\n\n::: callout-tip\n### Exercises\n\nThe genome of the plant *Arabidopsis thaliana* contains *33768* genes, of which *27655* are protein-coding and *6113* encode non-coding RNAs. Calculate the percentage of coding and non-coding genes in this genome using the following steps:\n\n1.  Create a variable named `ath_genes` that stores the numeric value *33768*.\n2.  Create 2 objects named `n_coding` and `n_noncoding` that store the numeric values *27655* and *6113*, respectively.\n3.  Create 2 objects named `perc_coding` and `perc_noncoding` by dividing `n_coding` and `n_noncoding` by `ath_genes`.\n4.  Update the objects by multiplying their contents by 100 (to represent in percentages, from 0 to 100) and rounding the percentages to 1 significant digit only.\n\n::: {.callout collapse=\"true\" appearance=\"minimal\"}\n### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Store values in objects\nath_genes <- 33768\nn_coding <- 27655\nn_noncoding <- 6113\n\n# Get percentages\nperc_coding <- n_coding / ath_genes\nperc_noncoding <- n_noncoding / ath_genes\n\n# Update objects with actual percentages\nperc_coding <- round(perc_coding * 100, 1)\nperc_noncoding <- round(perc_noncoding * 100, 1)\n\n# Show contents of the objects\nperc_coding\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 81.9\n```\n\n\n:::\n\n```{.r .cell-code}\nperc_noncoding\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 18.1\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Data structures\n\nNow, we will explore two data structures in R that we will use all the time throughout the lessons (and in our research routine): vectors and data frames.\n\n### Vectors\n\nVector are the most common data structures in R, and they are used to **store multiple values**. There are 6 kinds of values that can be stored in a vector, but the ones we typically use are:\n\n1.  `numeric`: numbers.\n2.  `character`: text strings.\n3.  `logical`: either `TRUE` or `FALSE`.\n\nThe other types are `integer`, `complex`, and `raw`, but they are not important here.\n\nTo create a vector, you will use the `c()` function to **combine** values. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating a numeric vector\ngenome_sizes <- c(33768, 52872, 39756)\ngenome_sizes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 33768 52872 39756\n```\n\n\n:::\n\n```{.r .cell-code}\n# Creating a character vector\nspecies <- c(\"Arabidopsis\", \"soybean\", \"maize\")\nspecies\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Arabidopsis\" \"soybean\"     \"maize\"      \n```\n\n\n:::\n:::\n\n\nYou can inspect vectors with the functions:\n\n-   `class()`: shows the class of a vector.\n-   `length()`: shows the number of elements in a vector.\n-   `str()`: summarizes the structure of a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(genome_sizes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\nlength(genome_sizes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(genome_sizes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n num [1:3] 33768 52872 39756\n```\n\n\n:::\n:::\n\n\nYou can also combine two vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies1 <- c(\"soybean\", \"maize\")\nspecies2 <- c(\"cotton\", \"bean\")\ncombined_species <- c(species1, species2)\ncombined_species\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"soybean\" \"maize\"   \"cotton\"  \"bean\"   \n```\n\n\n:::\n:::\n\n\n**NOTE:** Vectors can only store values of the same type (i.e., character, numeric, etc). If you try to create a vector that contains values of different types, R converts them to all be the same type. This conversion of one class to another is called *coercion*. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating a vector with numeric and character values\nc_vector <- c(\"a\", \"b\", 1, \"d\")\nc_vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"a\" \"b\" \"1\" \"d\"\n```\n\n\n:::\n:::\n\n\nIn the example above, R converted the numeric value *1* to a character.\n\n### Data frames\n\nData frames is the name R uses to call **tables**. To create a new data frame, you will use the `data.frame()` function. Each column of a data frame is a vector, so you can create a data frame by passing each vector to each column. For example, let's recreate the `genome_sizes` and `species` vectors we created in the previous section and store them in columns **genome_size** and **species** of a data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create vectors again\ngenome_sizes <- c(33768, 52872, 39756)\nspecies <- c(\"Arabidopsis\", \"soybean\", \"maize\")\n\n# Create a data frame with columns `genome_size` and `species`\ngenome_size_df <- data.frame(\n    genome_size = genome_sizes,\n    species = species\n)\n\ngenome_size_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  genome_size     species\n1       33768 Arabidopsis\n2       52872     soybean\n3       39756       maize\n```\n\n\n:::\n:::\n\n\nWe can also create the vectors inside the `data.frame()` function itself:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenome_size_df <- data.frame(\n    genome_size = c(33768, 52872, 39756),\n    species = c(\"Arabidopsis\", \"soybean\", \"maize\")\n)\n\ngenome_size_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  genome_size     species\n1       33768 Arabidopsis\n2       52872     soybean\n3       39756       maize\n```\n\n\n:::\n:::\n\n\nTo add a column to an existing data frame, you have to add `$` followed by the new column name in front of the object name. For example, let's add a column named `is_model` to the `genome_size_df` data frame that indicates whether or not a species is a model species:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add `is_model` column\ngenome_size_df$is_model <- c(TRUE, FALSE, FALSE)\ngenome_size_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  genome_size     species is_model\n1       33768 Arabidopsis     TRUE\n2       52872     soybean    FALSE\n3       39756       maize    FALSE\n```\n\n\n:::\n:::\n\n\nFinally, to inspect a data frame, you can use the following functions:\n\n-   `dim()`: shows the dimensions of the data frame (i.e., number of rows and columns, respectively).\n-   `nrow()`: shows the number of rows in a data frame.\n-   `ncol()`: shows the number of columns in a data frame.\n-   `head()`: shows the first 6 rows of a data frame.\n-   `tail()`: shows the last 6 rows of a data frame.\n-   `names()`: shows the column names.\n-   `rownames()`: shows the row names\n-   `str()`: summarizes the structure of a data frame.\n-   `summary()`: shows summary statistics for each column.\n\n::: callout-tip\n### Exercises\n\n1.  The plants Brussels sprout, grapevine and apple belong to the families Brassicaceae, Vitaceae, and Rosaceae. Create a data frame named `species_families` with 2 columns named **species** and **family** representing such information.\n\n::: {.callout collapse=\"true\" appearance=\"minimal\"}\n### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies_families <- data.frame(\n    species = c(\"Brussels sprout\", \"grapevine\", \"apple\"),\n    family = c(\"Brassicaceae\", \"Vitaceae\", \"Rosaceae\")\n)\n\nspecies_families\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n          species       family\n1 Brussels sprout Brassicaceae\n2       grapevine     Vitaceae\n3           apple     Rosaceae\n```\n\n\n:::\n:::\n\n:::\n\n2.  When you install R, it already comes with some example data sets. One of them is `airquality`, a data frame containing New York air quality measurements from May to September 1973. Inspect this data frame and answer the following questions:\n\n    -   How many rows are there?\n    -   How many columns are there?\n    -   What are the column names?\n    -   What are the classes of each column?\n\n::: {.callout collapse=\"true\" appearance=\"minimal\"}\n### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(airquality)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t153 obs. of  6 variables:\n $ Ozone  : int  41 36 12 18 NA 28 23 19 8 NA ...\n $ Solar.R: int  190 118 149 313 NA NA 299 99 19 194 ...\n $ Wind   : num  7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ...\n $ Temp   : int  67 72 74 62 56 66 65 59 61 69 ...\n $ Month  : int  5 5 5 5 5 5 5 5 5 5 ...\n $ Day    : int  1 2 3 4 5 6 7 8 9 10 ...\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Indexing and subsetting\n\nHere, you will learn how to extract specific elements of vectors and data frames, which is called **subsetting**.\n\n### Vectors\n\nTo subset vectors, you need to pass the index of the element you want to extract inside square brackets (`[]`). If you want to extract multiple elements, you have to pass a vector of indices inside the square brackets. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplants <- c(\"rice\", \"maize\", \"duckweed\")\n\n# Extract 1st element\nplants[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rice\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract 1st and 2nd element\nplants[c(1, 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rice\"  \"maize\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract 3rd and 2nd element (in this order)\nplants[c(3, 2)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"duckweed\" \"maize\"   \n```\n\n\n:::\n:::\n\n\nYou can also remove a given element by adding a minus (`-`) symbol before the index:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get all elements, except the 1st\nplants[-1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"maize\"    \"duckweed\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get all elements, except the 1st and 3rd\nplants[-c(1, 3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"maize\"\n```\n\n\n:::\n:::\n\n\nAnother very common way to subset vectors is by using **logical vectors**. When using logical vectors, `TRUE` and `FALSE` will indicate whether to **extract** or **not extract** the element. For example, let's use logical vectors to subset the `plants` vector we created above:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplants\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rice\"     \"maize\"    \"duckweed\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract 1st element, do not extract 2nd and 3rd elements\nplants[c(TRUE, FALSE, FALSE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rice\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract 1st and 3rd elements, do not extract 2nd\nplants[c(TRUE, FALSE, TRUE)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rice\"     \"duckweed\"\n```\n\n\n:::\n:::\n\n\nNow, you might be thinking: *using logical vectors seems complicated. Why would someone do this instead of using indices?*. The answer is **conditional subsetting**. In R, you can use logical expressions that return `TRUE` or `FALSE` to extract elements. For example, let's create a vector of genome sizes for fictional species and check if they more than 20,000 genes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nngenes <- c(52000, 35000, 18000, 17000, 22000, 11000, 13000)\n\n# Logical expression: is the element >= 20000?\nngenes > 20000\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nYou can see that the logical expression returns a vector of `TRUE`s and `FALSE`s. Since `TRUE` means **extract** and `FALSE` means **do not extract** when subsetting, we can use logical expressions to subset vectors as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract elements with >=20000 genes\nngenes[ngenes > 20000]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 52000 35000 22000\n```\n\n\n:::\n:::\n\n\nYou can combine multiple tests in logical expressions using `&` (which means **AND**, both conditions are true) and `|` (which means **OR**, at least one of the conditions is true).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract elements with number of genes between 20000 and 40000\nngenes[ngenes > 20000 & ngenes < 40000]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 35000 22000\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract elements with 13000 or 11000 genes\nngenes[ngenes == 13000 | ngenes == 11000]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11000 13000\n```\n\n\n:::\n:::\n\n\nYou can also subset a vector based on the presence of some pre-defined elements using the `%in%` operator. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanimals <- c(\"dog\", \"cat\", \"rat\", \"pig\", \"horse\")\n\nanimals[animals %in% c(\"cat\", \"dog\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"dog\" \"cat\"\n```\n\n\n:::\n:::\n\n\n### Data frames\n\nSubsetting data frames in very similar to subsetting vectors. The only difference is that data frames have 2 dimensions (rows and columns), while vectors have only 1 dimension. Thus, when you subset a data frame, you have to specify which dimension you want to use. For instance, if you execute `vec[2]`, you will extract the 2nd element of the vector `vec`. However, if you pass the index 2 to a data frame, you can mean either the 2nd row or the second column. To subset data frames, you will use commas (`,`) inside square brackets to distinguish rows (which come **before** the comma) from columns (which come **after** the comma. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# See the first 6 rows the `airquality` data frame\nhead(airquality)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Ozone Solar.R Wind Temp Month Day\n1    41     190  7.4   67     5   1\n2    36     118  8.0   72     5   2\n3    12     149 12.6   74     5   3\n4    18     313 11.5   62     5   4\n5    NA      NA 14.3   56     5   5\n6    28      NA 14.9   66     5   6\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract the element in row 1, column 2\nairquality[1, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 190\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract rows 1 to 5, column 1 - note: `1:5` is the same as `c(1, 2, 3, 4, 5)`\nairquality[1:5, 1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 41 36 12 18 NA\n```\n\n\n:::\n:::\n\n\nTo extract all rows or all columns, leave the corresponding field empty:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract row 2, all columns\nairquality[2, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Ozone Solar.R Wind Temp Month Day\n2    36     118    8   72     5   2\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract column 2, all rows\nairquality[, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 190 118 149 313  NA  NA 299  99  19 194  NA 256 290 274  65 334 307  78\n [19] 322  44   8 320  25  92  66 266  NA  13 252 223 279 286 287 242 186 220\n [37] 264 127 273 291 323 259 250 148 332 322 191 284  37 120 137 150  59  91\n [55] 250 135 127  47  98  31 138 269 248 236 101 175 314 276 267 272 175 139\n [73] 264 175 291  48 260 274 285 187 220   7 258 295 294 223  81  82 213 275\n [91] 253 254  83  24  77  NA  NA  NA 255 229 207 222 137 192 273 157  64  71\n[109]  51 115 244 190 259  36 255 212 238 215 153 203 225 237 188 167 197 183\n[127] 189  95  92 252 220 230 259 236 259 238  24 112 237 224  27 238 201 238\n[145]  14 139  49  20 193 145 191 131 223\n```\n\n\n:::\n:::\n\n\nYou can also subset columns based on their names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nairquality$Month\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6\n [38] 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7\n [75] 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n[112] 8 8 8 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9\n[149] 9 9 9 9 9\n```\n\n\n:::\n\n```{.r .cell-code}\nairquality[, \"Month\"] # same thing\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6\n [38] 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7\n [75] 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n[112] 8 8 8 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9\n[149] 9 9 9 9 9\n```\n\n\n:::\n:::\n\n\nAs we did with vectors, we can subset the data frame using logical expressions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract rows for which column \"Month\" is equal to 5\nairquality[airquality$Month == 5, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Ozone Solar.R Wind Temp Month Day\n1     41     190  7.4   67     5   1\n2     36     118  8.0   72     5   2\n3     12     149 12.6   74     5   3\n4     18     313 11.5   62     5   4\n5     NA      NA 14.3   56     5   5\n6     28      NA 14.9   66     5   6\n7     23     299  8.6   65     5   7\n8     19      99 13.8   59     5   8\n9      8      19 20.1   61     5   9\n10    NA     194  8.6   69     5  10\n11     7      NA  6.9   74     5  11\n12    16     256  9.7   69     5  12\n13    11     290  9.2   66     5  13\n14    14     274 10.9   68     5  14\n15    18      65 13.2   58     5  15\n16    14     334 11.5   64     5  16\n17    34     307 12.0   66     5  17\n18     6      78 18.4   57     5  18\n19    30     322 11.5   68     5  19\n20    11      44  9.7   62     5  20\n21     1       8  9.7   59     5  21\n22    11     320 16.6   73     5  22\n23     4      25  9.7   61     5  23\n24    32      92 12.0   61     5  24\n25    NA      66 16.6   57     5  25\n26    NA     266 14.9   58     5  26\n27    NA      NA  8.0   57     5  27\n28    23      13 12.0   67     5  28\n29    45     252 14.9   81     5  29\n30   115     223  5.7   79     5  30\n31    37     279  7.4   76     5  31\n```\n\n\n:::\n\n```{.r .cell-code}\n# Extract rows with \"Temp\" >90, then show only columns \"Month\" and \"Day\"\nairquality[airquality$Temp > 90, c(\"Month\", \"Day\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    Month Day\n42      6  11\n43      6  12\n69      7   8\n70      7   9\n75      7  14\n102     8  10\n120     8  28\n121     8  29\n122     8  30\n123     8  31\n124     9   1\n125     9   2\n126     9   3\n127     9   4\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n### Exercises\n\nSubset the `airquality` data set to answer the following questions:\n\n1.  How many days (rows) observations have ozone levels \\>40 ppb?\n2.  How many days have wind speed between 10 and 15 mph?\n3.  What are the minimum and maximum temperature?\n4.  How many days have solar radiation \\<100 Langleys?\n\n::: {.callout collapse=\"true\" appearance=\"minimal\"}\n### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Q1: Ozone levels >40 ppb\nnrow(airquality[airquality$Ozone > 40, ])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 82\n```\n\n\n:::\n\n```{.r .cell-code}\n# Q2: Wind speed between 10 and 15 mph\nnrow(airquality[airquality$Wind >= 10 & airquality$Wind <=15, ])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 62\n```\n\n\n:::\n\n```{.r .cell-code}\n# Q3: Minimum and maximum temperature\nsummary(airquality)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Ozone           Solar.R           Wind             Temp      \n Min.   :  1.00   Min.   :  7.0   Min.   : 1.700   Min.   :56.00  \n 1st Qu.: 18.00   1st Qu.:115.8   1st Qu.: 7.400   1st Qu.:72.00  \n Median : 31.50   Median :205.0   Median : 9.700   Median :79.00  \n Mean   : 42.13   Mean   :185.9   Mean   : 9.958   Mean   :77.88  \n 3rd Qu.: 63.25   3rd Qu.:258.8   3rd Qu.:11.500   3rd Qu.:85.00  \n Max.   :168.00   Max.   :334.0   Max.   :20.700   Max.   :97.00  \n NA's   :37       NA's   :7                                       \n     Month            Day      \n Min.   :5.000   Min.   : 1.0  \n 1st Qu.:6.000   1st Qu.: 8.0  \n Median :7.000   Median :16.0  \n Mean   :6.993   Mean   :15.8  \n 3rd Qu.:8.000   3rd Qu.:23.0  \n Max.   :9.000   Max.   :31.0  \n                               \n```\n\n\n:::\n\n```{.r .cell-code}\n# Q4: Solar radiation <100 Langleys\nnrow(airquality[airquality$Solar.R < 100, ])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 41\n```\n\n\n:::\n:::\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}