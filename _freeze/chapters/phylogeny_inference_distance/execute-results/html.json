{
  "hash": "30b27684a7ab6463fe7b46304c191980",
  "result": {
    "engine": "knitr",
    "markdown": "\n# Distance-based phylogeny inference\n\nThe simplest way to infer a phylogeny is to use pairwise distances between\nsequences, which are calculated from Multiple Sequence Alignments (MSA).\nPairwise distances are typically stored in **distance matrices**, which\nare used to infer a phylogenetic tree using algorithms such as *UPGMA* or\n*neighbor-joining*. In this lesson, we will guide on you on how to\ninfer a phylogeny from sequences.\n\n## Goals of this lesson\n\nIn this lesson, you will learn to:\n\n- perform MSA\n- calculate distances from MSA\n- infer phylogenetic trees from distance matrices\n\n## Multiple Sequence Alignment (MSA)\n\nThere are several algorithms to perform an MSA, such as \nClustalW [@thompson1994clustal], ClustalOmega [@sievers2011fast], \nMUSCLE [@edgar2004muscle], and MAFFT [@katoh2013mafft]. Comparing them\nand deciding which one is the best is beyond the scope of this lesson. Here,\nwe will perform MSA with the Bioconductor package msa [@bodenhofer2015msa],\nwhich provides native implementations of the ClustalW, ClustalOmega, and MUSCLE\nalgorithms. \n\nmsa comes with an example FASTA file containing protein sequences\nof hemoglobin subunit alpha 1 in multiple species. Let's start by reading \nthe example file:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(msa)\nlibrary(Biostrings)\n\n# Path to example file\nfasta_path <- system.file(\"examples\", \"HemoglobinAA.fasta\", package=\"msa\")\nfasta_path\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/home/faalm/R/x86_64-pc-linux-gnu-library/4.3/msa/examples/HemoglobinAA.fasta\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Read example file\nhemoglobin_seqs <- readAAStringSet(fasta_path)\nhemoglobin_seqs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAAStringSet object of length 17:\n     width seq                                              names               \n [1]   141 VLSPADKTNVKAAWGKVGAHAGE...AVHASLDKFLASVSTVLTSKYR HBA1_Homo_sapiens\n [2]   141 VLSPADKSNVKAAWGKVGGHAGE...AVHASLDKFLASVSTVLTSKYR HBA1_Macaca_mulatta\n [3]   141 MLTDAEKKEVTALWGKAAGHGEE...SAHAAMDKFLSKVATVLTSKYR HBA1_Ornithorhync...\n [4]   141 VLSAADKGNVKAAWGKVGGHAAE...AVHASLDKFLANVSTVLTSKYR HBA1_Bos_taurus\n [5]   141 VLSAADKTNVKAAWSKVGGNSGA...EIHASLDKFLALLSTVLTSKYR HBA1_Monodelphis_...\n ...   ... ...\n[13]   141 VLSPADKTNVKGTWSKIGNHSAE...SVHASLDKFLASVSTVLTSKYR HBA1_Tursiops_tru...\n[14]   141 HLTADDKKHIKAIWPSVAAHGDK...ATHKALDKFLVSVSNVLTSKYR HBA1_Xenopus_trop...\n[15]   141 VLTEEDKARVRVAWVPVSKNAEL...EVLLSVDKFLGQISKVLASRYR HBA1_Microcephalo...\n[16]   142 MVLSPADKTNVKAAWGKVGAHAG...AVHASLDKFLASVSTVLTSKYR HBA1_Pan_troglodytes\n[17]   142 MVLSADDKTNIKNCWGKIGGHGG...AMHASLDKFLASVSTVLTSKYR HBA1_Rattus_norve...\n```\n\n\n:::\n:::\n\n\nNow, we will use the function `msa()` to perform an MSA using the default\nalgorithm (ClustalW). You can also use other algorithms by changing the \nargument passed to the `method` parameter.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform MSA\nhemoglobin_aln <- msa(hemoglobin_seqs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nuse default substitution matrix\n```\n\n\n:::\n\n```{.r .cell-code}\nhemoglobin_aln\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCLUSTAL 2.1  \n\nCall:\n   msa(hemoglobin_seqs)\n\nMsaAAMultipleAlignment with 17 rows and 143 columns\n     aln                                                   names\n [1] -VLSPADKTNVKAAWGKVGAHAGEY...FTPAVHASLDKFLASVSTVLTSKYR HBA1_Homo_sapiens\n [2] MVLSPADKTNVKAAWGKVGAHAGEY...FTPAVHASLDKFLASVSTVLTSKYR HBA1_Pan_troglodytes\n [3] -VLSPADKSNVKAAWGKVGGHAGEY...FTPAVHASLDKFLASVSTVLTSKYR HBA1_Macaca_mulatta\n [4] -VLSAADKGNVKAAWGKVGGHAAEY...FTPAVHASLDKFLANVSTVLTSKYR HBA1_Bos_taurus\n [5] -VLSPADKTNVKGTWSKIGNHSAEY...FTPSVHASLDKFLASVSTVLTSKYR HBA1_Tursiops_tru...\n [6] -VLSGEDKSNIKAAWGKIGGHGAEY...FTPAVHASLDKFLASVSTVLTSKYR HBA1_Mus_musculus\n [7] MVLSADDKTNIKNCWGKIGGHGGEY...FTPAMHASLDKFLASVSTVLTSKYR HBA1_Rattus_norve...\n [8] -VLSATDKANVKTFWGKLGGHGGEY...FTPAVHASLDKFLATVATVLTSKYR HBA1_Erinaceus_eu...\n [9] -VLSAADKSNVKACWGKIGSHAGEY...FTPAVHASLDKFFSAVSTVLTSKYR HBA1_Felis_silves...\n[10] -VLSPADKTNIKSTWDKIGGHAGDY...FTPAVHASLDKFFTAVSTVLTSKYR HBA1_Chrysocyon_b...\n[11] -VLSDNDKTNVKATWSKVGDHASDY...FTPEVHASLDKFLSNVSTVLTSKYR HBA1_Loxodonta_af...\n[12] -VLSAADKTNVKAAWSKVGGNSGAY...FTPEIHASLDKFLALLSTVLTSKYR HBA1_Monodelphis_...\n[13] -MLTDAEKKEVTALWGKAAGHGEEY...FTPSAHAAMDKFLSKVATVLTSKYR HBA1_Ornithorhync...\n[14] -VLSAADKNNVKGIFTKIAGHAEEY...LTPEVHASLDKFLCAVGTVLTAKYR HBA1_Gallus_gallus\n[15] -HLTADDKKHIKAIWPSVAAHGDKY...FDPATHKALDKFLVSVSNVLTSKYR HBA1_Xenopus_trop...\n[16] -VLTEEDKARVRVAWVPVSKNAELY...LKPEVLLSVDKFLGQISKVLASRYR HBA1_Microcephalo...\n[17] -SLSDTDKAVVKAIWAKISPKADEI...FTPEVHVSVDKFFNNLALALSEKYR HBA1_Danio_rerio\n Con -VLS?ADK?NVKA?WGK?GGHA?EY...FTPAVHASLDKFLA?VSTVLTSKYR Consensus \n```\n\n\n:::\n:::\n\n\nNow that we have an MSA, we can calculate distances.\n\n## Calculating distance matrices\n\nHere, we will calculate distance matrices using 2 different methods:\n\n- the `aastring2dist()` function from\n[MSA2dist](https://bioconductor.org/packages/MSA2dist), which calculates \ndistances from `AAStringSet` objects using a score matrix. Here, we will\nuse the Grantham matrix [@grantham1974amino].\n\n- the `dist.alignment()` function from [seqinr](https://cran.r-project.org/web/packages/seqinr/index.html), \nwhich calculates distances from `alignment` objects using a similarity\nor identity matrix. Here, we will use the identity matrix.\n\nFirst, as these 2 functions take different data classes as input, we will\nhave to convert the `hemoglobin_aln` object to the right classes for each \nfunction.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert `MsaAAMultipleAlignment` to `AAStringSet` for MSA2dist\naln_msa2dist <- as(hemoglobin_aln, \"AAStringSet\")\n\n# Convert `MsaAAMultipleAlignment` to `alignment` for seqinr\naln_seqinr <- msaConvert(hemoglobin_aln, type = \"seqinr::alignment\")\n```\n:::\n\n\nNow, we can calculate the distance matrices.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MSA2dist)\nlibrary(seqinr)\n\n# Calculate distance matrix with `MSA2dist::aastring2dist()`\ndist_matrix1 <- aastring2dist(aa = aln_msa2dist, score = granthamMatrix())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nComputing: [========================================] 100% (done)                         \n```\n\n\n:::\n\n```{.r .cell-code}\ndist_matrix1 <- as.dist(dist_matrix1$distSTRING)\n\n\n# Calculate distance matrix with `seqinr::dist.alignment()`\ndist_matrix2 <- dist.alignment(aln_seqinr, matrix = \"identity\")\n\n\n# Inspect distance matrices\nhead(dist_matrix1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  0.000000  2.347518  9.035461  9.446809  8.304965 15.702128\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(dist_matrix2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.0000000 0.1684304 0.3472281 0.4038819 0.3766218 0.4688903\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(dist_matrix1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"dist\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(dist_matrix2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"dist\"\n```\n\n\n:::\n:::\n\n\nAs you can see, distance matrices are stored in objects of class `dist`. This\nis the data class that we will use to infer phylogenetic trees.\n\n## Inferring trees\n\nNow, we will use the `bionjs()` function from ape to infer neighbor-joining\ntrees using the two distance matrices we calculated in the previous section.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ape)\n\n# Infer neighbor-joining trees\ntree1 <- bionjs(dist_matrix1)\ntree2 <- bionjs(dist_matrix2)\n\n# Plotting trees\nplot(tree1)\n```\n\n::: {.cell-output-display}\n![](phylogeny_inference_distance_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(tree2)\n```\n\n::: {.cell-output-display}\n![](phylogeny_inference_distance_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n\n\nThe two methods lead to different tree topologies. How do you know which one\nis \"true\", then? This is the topic of the next lesson, where you will learn \nhow to use maximum likelihood to assess trees.\n\n\n::: {.callout-tip}\n\n### Exercises\n\nUse the `dist_matrix1` object to infer a phylogeny using the `upgma()` function\nfrom the phangorn package [@phangorn]. Is the topology the same as the \ntopology of `tree1`?\n\n::: {.callout collapse=\"true\" appearance=\"minimal\"}\n\n### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Infer UPGMA tree and compare topologies\ntree_upgma <- phangorn::upgma(dist_matrix1)\nplot(tree_upgma)\n```\n\n::: {.cell-output-display}\n![](phylogeny_inference_distance_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n:::\n:::\n\n\n## References {.unnumbered}\n\n",
    "supporting": [
      "phylogeny_inference_distance_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}