{
  "hash": "e4bb9165ce0f6f09958541721ecc2578",
  "result": {
    "engine": "knitr",
    "markdown": "\n# R for evolutionary biology: data structures\n\nR is a very flexible programming language, and it allows developers to\ncreate their own data structures (called **classes**) for their packages.\nOver the years, some packages have become so popular that the classes\nthey use to store data are now used the \"standard\" representations for\nparticular types of data. Here, we will show some common data classes in\nevolutionary biology and comparative genomics research.\n\n## Goals of this lesson\n\nIn this lesson, you will learn to:\n\n- represent and work with sequence data using `XString` and `XStringSet`\nobjects\n- represent and work with multiple sequence alignments \nusing `XMultipleAlignment` objects\n- represent and work with phylogenies using `phylo` objects\n\n## The Bioconductor ecosystem\n\n[The Bioconductor project](https://bioconductor.org/) was created to develop,\nsupport, and disseminate free open source software to analyze biological data.\nIt works as a repository of R packages for biological data analysis, with\nboth \"core packages\" (developed and maintained by the Bioconductor Core Team),\nand community-contributed packages. We usually refer to Bioconductor as a\n\"package ecosystem\" because its packages are tightly integrated and designed\nfor easy interoperation, such that different packages can be used together\nwith minimal effort. An important facilitator of such interoperability is\nthe existence of standardized data structures, such as `GRanges` objects\nfor genomic coordinates, and `DNA/RNA/AAStringSet` objects for sequences.\n\n### The {Biostrings} package and `XStringSet` objects\n\nThe Biostrings package [@biostrings] allows efficient manipulation of \nbiological sequences, and its data classes are standard for all Bioconductor\npackages that involve sequence analyses. The data classes in Biostrings to\nrepresent sets of biological sequences are:\n\n1. `DNAStringSet`: for sets of DNA strings.\n2. `RNAStringSet`: for sets of RNA strings.\n3. `AAStringSet`: for sets of amino acid strings.\n\nFor a single sequence, the each of the above has a correspoding `XString` class\n(i.e., `DNAString`, `RNAString`, `AAString`). For example, let's create some\n`XString` objects manually:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Biostrings)\n\n# Create `DNAString` object\ndna_seq <- DNAString(\"ATGGCCGACTCA\")\ndna_seq\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n12-letter DNAString object\nseq: ATGGCCGACTCA\n```\n\n\n:::\n\n```{.r .cell-code}\n# Convert `DNAString` to `RNAString`\nrna_seq <- RNAString(dna_seq)\nrna_seq\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n12-letter RNAString object\nseq: AUGGCCGACUCA\n```\n\n\n:::\n\n```{.r .cell-code}\n# Translate `RNAString` to create `AAString`\naa_seq <- translate(rna_seq)\naa_seq\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n4-letter AAString object\nseq: MADS\n```\n\n\n:::\n:::\n\n\nIn real-world data analyses, we would work with multiple sequences (e.g., \na whole genome or a whole proteome). Multiple sequences are stored \nin `XStringSet` objects, which can be read from FASTA files \nwith `readXStringSet()` functions, namely:\n\n1. `readDNAStringSet()`: read FASTA file containing multiple DNA sequences.\n2. `readRNAStringSet()`: read FASTA file containing multiple RNA sequences. \n3. `readAAStringSet()`: read FASTA file containing multiple AA sequences.\n\nFor example, let's read an example FASTA file that come with the Biostrings\npackage.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Path to FASTA file containing an ORF\nfasta_file <- system.file(\"extdata\", \"someORF.fa\", package = \"Biostrings\")\nfasta_file\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/home/faalm/R/x86_64-pc-linux-gnu-library/4.3/Biostrings/extdata/someORF.fa\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Read FASTA file as a DNAStringSet object\ndna_seqs <- readDNAStringSet(fasta_file)\ndna_seqs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDNAStringSet object of length 7:\n    width seq                                               names               \n[1]  5573 ACTTGTAAATATATCTTTTATTT...CTTATCGACCTTATTGTTGATAT YAL001C TFC3 SGDI...\n[2]  5825 TTCCAAGGCCGATGAATTCGACT...AGTAAATTTTTTTCTATTCTCTT YAL002W VPS8 SGDI...\n[3]  2987 CTTCATGTCAGCCTGCACTTCTG...TGGTACTCATGTAGCTGCCTCAT YAL003W EFB1 SGDI...\n[4]  3929 CACTCATATCGGGGGTCTTACTT...TGTCCCGAAACACGAAAAAGTAC YAL005C SSA1 SGDI...\n[5]  2648 AGAGAAAGAGTTTCACTTCTTGA...ATATAATTTATGTGTGAACATAG YAL007C ERP2 SGDI...\n[6]  2597 GTGTCCGGGCCTCGCAGGCGTTC...AAGTTTTGGCAGAATGTACTTTT YAL008W FUN14 SGD...\n[7]  2780 CAAGATAATGTCAAAGTTAGTGG...GCTAAGGAAGAAAAAAAAATCAC YAL009W SPO7 SGDI...\n```\n\n\n:::\n:::\n\n\nSome examples of what you can do to explore `XStringSet` objects include:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# width(): get sequence lengths\nwidth(dna_seqs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5573 5825 2987 3929 2648 2597 2780\n```\n\n\n:::\n\n```{.r .cell-code}\n# names(): get sequence names\nnames(dna_seqs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"YAL001C TFC3 SGDID:S0000001, Chr I from 152168-146596, reverse complement, Verified ORF\"\n[2] \"YAL002W VPS8 SGDID:S0000002, Chr I from 142709-148533, Verified ORF\"                    \n[3] \"YAL003W EFB1 SGDID:S0000003, Chr I from 141176-144162, Verified ORF\"                    \n[4] \"YAL005C SSA1 SGDID:S0000004, Chr I from 142433-138505, reverse complement, Verified ORF\"\n[5] \"YAL007C ERP2 SGDID:S0000005, Chr I from 139347-136700, reverse complement, Verified ORF\"\n[6] \"YAL008W FUN14 SGDID:S0000006, Chr I from 135916-138512, Verified ORF\"                   \n[7] \"YAL009W SPO7 SGDID:S0000007, Chr I from 134856-137635, Verified ORF\"                    \n```\n\n\n:::\n\n```{.r .cell-code}\n# subset DNAStringSet and create a DNAStringSet of length 1\ndna_seqs[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDNAStringSet object of length 1:\n    width seq                                               names               \n[1]  5573 ACTTGTAAATATATCTTTTATTT...CTTATCGACCTTATTGTTGATAT YAL001C TFC3 SGDI...\n```\n\n\n:::\n\n```{.r .cell-code}\n# subset DNAStringSet and create a DNAString object\ndna_seqs[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n5573-letter DNAString object\nseq: ACTTGTAAATATATCTTTTATTTTCCGAGAGGAAAA...AATTTCTTAAACGCTTATCGACCTTATTGTTGATAT\n```\n\n\n:::\n:::\n\n\nAll functions above would also work for `AAStringSet` objects \nand `RNAStringSet` objects.\n\n\n::: {.callout-tip}\n\n### Exercises\n\nUse the `dna_seqs` object created above to answer the following questions:\n\n1. What is the length of the 3rd sequence?\n2. What is the name of the 5th sequence?\n3. How many times does the **TTCC** sequence string occur in each sequence?\nHint: use the function `vcountPattern()`.\n4. What are the first 3 nucleotides of each sequence? \nHint: use the `subseq()` function.\n\n::: {.callout collapse=\"true\" appearance=\"minimal\"}\n\n### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Q1: Length of the 3rd sequence\nwidth(dna_seqs)[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2987\n```\n\n\n:::\n\n```{.r .cell-code}\n# Q2: Name of the 5th sequence\nnames(dna_seqs)[5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"YAL007C ERP2 SGDID:S0000005, Chr I from 139347-136700, reverse complement, Verified ORF\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Q3: Minimum and maximum temperature\nvcountPattern(\"TTCC\", dna_seqs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21 28 16 23 15  8  5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Q4: First 3 nucleotides of each sequence\nsubseq(dna_seqs, start = 1, end = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDNAStringSet object of length 7:\n    width seq                                               names               \n[1]     3 ACT                                               YAL001C TFC3 SGDI...\n[2]     3 TTC                                               YAL002W VPS8 SGDI...\n[3]     3 CTT                                               YAL003W EFB1 SGDI...\n[4]     3 CAC                                               YAL005C SSA1 SGDI...\n[5]     3 AGA                                               YAL007C ERP2 SGDI...\n[6]     3 GTG                                               YAL008W FUN14 SGD...\n[7]     3 CAA                                               YAL009W SPO7 SGDI...\n```\n\n\n:::\n:::\n\n\n:::\n:::\n\n\n### The {Biostrings} package and `XMultipleAlignment` objects\n\nLike `XStringSet` objects, `XMultipleAlignment` objects also store sequences,\nbut sequences that were aligned using a Sequence Alignment algorithm.\nFASTA files containing aligned sequences can be read with \n`XMultipleAlignment` functions, namely:\n\n1. `readDNAMultipleAlignment()`: read a FASTA file containing aligned DNA\nsequences.\n2. `readRNAMultipleAlignment()`: read a FASTA file containing aligned RNA\nsequences.\n3. `readAAMultipleAlignment()`: read a FASTA file containing aligned amino acid\nsequences.\n\n\nFor example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Path to FASTA file containing MSA of DNA sequences\naln_path <- system.file(\"extdata\", \"msx2_mRNA.aln\", package = \"Biostrings\")\naln_path\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/home/faalm/R/x86_64-pc-linux-gnu-library/4.3/Biostrings/extdata/msx2_mRNA.aln\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Read MSA file\ndna_msa <- readDNAMultipleAlignment(aln_path)\ndna_msa\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDNAMultipleAlignment with 8 rows and 2343 columns\n     aln                                                    names               \n[1] -----TCCCGTCTCCGCAGCAAAAAA...TCACAATTAAAAAAAAAAAAAAAAA gi|84452153|ref|N...\n[2] --------------------------...------------------------- gi|208431713|ref|...\n[3] --------------------------...------------------------- gi|118601823|ref|...\n[4] ----------------------AAAA...------------------------- gi|114326503|ref|...\n[5] --------------------------...------------------------- gi|119220589|ref|...\n[6] --------------------------...------------------------- gi|148540149|ref|...\n[7] --------------CGGCTCCGCAGC...------------------------- gi|45383056|ref|N...\n[8] GGGGGAGACTTCAGAAGTTGTTGTCC...------------------------- gi|213515133|ref|...\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-tip}\n\n### Exercises\n\nWhat is the consensus sequence of the multiple sequence alignment in `dna_msa`?\nHint: use the `consensusString()` function.\n\n::: {.callout collapse=\"true\" appearance=\"minimal\"}\n\n### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconsensusString(dna_msa)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"----------------------VWVMKYYBSRSTSDYVVMDKBHSVGHKSMSVRYVKDRYHRHKVSBYDNVVRVYWMSYNGVRCRGABAMGTCA-YRGCTTCTCYGTSCAWAGGCRRTGRCYTGTTYTCGYCCRRYGARGAGGGCCCVGCRGTKSTSGCCSGMCSRGGCCCVGGGCCYGGRGGMGCCGAGGGVGSCGMRGAGGAGCRCMRSGTCAAGGTCTCCAGCYTGCCCTTCAGYGTGGAGGCGCTCATGTCSGACAAGAARCCGCCYAAGGARKCGYCSSCGSKGCCRSCCGAMWGCGSCTCSGCYGGSGCYRYCCTGSGG----CCR-----CTGCTGCTGYCGGGVCACGGCGYYCGG-GAMGCKCMCAGYCCC---GGGCCKCTSGTSAARMCCTTCGAGACCGCCTCGGTCAAGTCGGARAAYTCMGARGAYGGARCGBCGTGGATVCAGGARCCCGGCMGATAYTCSCCKCCGCCMAGACAYATGAGCCCYACMRCCTGCACCCTGMGGAARCACAAGACCAAYCGGAAGCCVCGCACVCCCTTYACCACRTCCCAGCTYCTVGCCYTGGAGCGCAAGTTCCGYCAGAAACAGTACCTSTCCATYGCAGAGCGKGCMGAGTTCTCCAGCTCYCTGAACCTYACAGAGACCCAGGTCAAAATCTGGTTCCARAAYCGAAGGGCYAAGGCSAARAGACTGCAGGAGGCRGARCTRGARAAGCTSAARATGGCTGCMAARCCTATGYTGCCCTCVRGCTTCAGYCTBCCYTTCCCYATCARCTCSCCCYTGCARGCRGCRTCCMTATAYGGMRCRTCYTACCCBTTYCATAGACCTGTGC---TYCCYATCCCGCCYGT-BGGACTCTATGCSACBCCRGTSGGATATRGCATGTACCAYCTRTCCTAAGGAAGACCAGATSRRY-MGACTCCAGGATGGRTGWYTGYYTRAWAGMMTYYCCCNTCCMKCTYCRAGAAKGCRGTRCCAAYYY-TRSWMCTGMA-YGCWARCYYTGCRT-YGTCACCCTAASCRDCWRGGCTG--RCAGGRCYACWYGAYAYAGADBVAATTTGTTMTKTAGGYRRSAGRCACY-AAGMCYKGKTTTSTTKKYATARTYYYCYRRRTGC--CCCCTTTTCCYYTCASARW-KATTGGCTCTGMTAGTTTTTATGTATAAATATATA------ATAAAATATAAKAC--TTTTTATAYRSCARATGTAAAAATTCAAVYTRTKYTRDAW--GSCAAARTTTRTWKRHWYRYKTVBYHDKWTW---------YVTRKVTMDSMTYHYYHHMWRAHWHYSWGW-WAGYYC---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\"\n```\n\n\n:::\n:::\n\n\n:::\n:::\n\n\n\n## The {ape} package and `phylo` objects\n\nThe ape package [@ape] is one of the most popular packages for Analyses\nof Phylogenetics and Evolution (from where the name comes), and it\nrepresents phylogenies as `phylo` objects. Because of ape's popularity,\n`phylo` objects have become the standard data structure for phylogenies in R.\n\nTo create `phylo` objects, you will use the function `read.tree()`, which\naccepts both the path to a file containing the tree (in Newick format,\nfor example), or a text representation of a phylogeny. To demonstrate\nthe structure of a `phylo` object, let's create a phylogeny from text:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ape)\n\n# Create tree from text\ntext_tree <- \"((((cow, pig),whale), (bat, (lemur, human))), iguana);\"\ntree <- read.tree(text = text_tree)\n\ntree\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nPhylogenetic tree with 7 tips and 6 internal nodes.\n\nTip labels:\n  cow, pig, whale, bat, lemur, human, ...\n\nRooted; no branch lengths.\n```\n\n\n:::\n:::\n\n\nThis is what a `phylo` object looks like. In a sense, a `phylo` object is a \n`list`, a standard R data structure, but with some standard elements. Let's\nexplore them:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Structure of the `phylo` object\nstr(tree)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 3\n $ edge     : int [1:12, 1:2] 8 9 10 11 11 10 9 12 12 13 ...\n $ Nnode    : int 6\n $ tip.label: chr [1:7] \"cow\" \"pig\" \"whale\" \"bat\" ...\n - attr(*, \"class\")= chr \"phylo\"\n - attr(*, \"order\")= chr \"cladewise\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# Exploring each element individually\ntree$edge\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2]\n [1,]    8    9\n [2,]    9   10\n [3,]   10   11\n [4,]   11    1\n [5,]   11    2\n [6,]   10    3\n [7,]    9   12\n [8,]   12    4\n [9,]   12   13\n[10,]   13    5\n[11,]   13    6\n[12,]    8    7\n```\n\n\n:::\n\n```{.r .cell-code}\ntree$Nnode\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\ntree$tip.label\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"cow\"    \"pig\"    \"whale\"  \"bat\"    \"lemur\"  \"human\"  \"iguana\"\n```\n\n\n:::\n:::\n\n\nAs `phylo` objects have become standard, there are hundreds of functions\n(from dozens of packages) that were especially designed to work on\n`phylo` objects. For example, if you want to plot the tree, you would use\nthe `plot()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot tree\nplot(tree)\n```\n\n::: {.cell-output-display}\n![](data_structures_genomics_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nWe will explore other examples in future lessons.\n\n\n::: {.callout-tip}\n\n### Exercises\n\nUse the following code to simulate a random tree and answer the questions below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123) # for reproducibility\nsim_tree <- rtree(n = 20)\n```\n:::\n\n\n1. How many terminal taxa (i.e., tips) are there?\n2. What the the names of terminal taxa?\n3. What taxon is more closely-related to the taxon \"t1\"?\n\n\n::: {.callout collapse=\"true\" appearance=\"minimal\"}\n\n### Solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Q1: Number of terminal taxa\nNtip(sim_tree)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n\n```{.r .cell-code}\n# Q2: Names of terminal taxa\nsim_tree$tip.label\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"t5\"  \"t19\" \"t9\"  \"t3\"  \"t8\"  \"t10\" \"t7\"  \"t15\" \"t18\" \"t17\" \"t4\"  \"t1\" \n[13] \"t11\" \"t14\" \"t20\" \"t13\" \"t16\" \"t2\"  \"t12\" \"t6\" \n```\n\n\n:::\n\n```{.r .cell-code}\n# Q3: Visualizing the tree to check who is more closely-related to 't1'\nplot(sim_tree)\n```\n\n::: {.cell-output-display}\n![](data_structures_genomics_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n:::\n:::\n\n\n## References {.unnumbered}\n\n",
    "supporting": [
      "data_structures_genomics_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}