[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Computational Evolutionary Biology",
    "section": "",
    "text": "Preface\nThis book aims to provide learners with a hands-on introduction to Computational Evolutionary Biology, and the materials here are used in the practical lessons of the courses C003709A - Evolutionary Biology and C000500A - Bioinformatics 2 at Universiteit Gent, taught by Dr. Yves Van de Peer and Fabricio Almeida-Silva.\nEach book chapter represents the contents of a practical lesson from the UGent courses, and they serve both as a guide during the lessons and as a reference to go back later.\nThe book will cover:"
  },
  {
    "objectID": "index.html#setup",
    "href": "index.html#setup",
    "title": "Introduction to Computational Evolutionary Biology",
    "section": "Setup",
    "text": "Setup\nTo run the code in this book, you will need to install:\n\nR (&gt;=4.2.0): go to the CRAN website, choose your OS (Windows, Linux, or macOS), and follow the installation instructions.\nRStudio Desktop: go to the RStudio website and download the installer for your OS.\nIQ-TREE: go to the IQ-TREE download page and follow the installation instructions for your OS.\n\nAfter installing R and RStudio, you will need to install some required R packages. To do that, open RStudio and execute the code below in your console:\n\n# Install BiocManager\ninstall.packages(\"BiocManager\")\n\n# Use BiocManager to install required packages\npackages &lt;- c(\n    \"treeio\", \n    \"ggtree\", \n    \"ggtree\", \n    \"ape\", \n    \"here\", \n    \"Biostrings\",\n    \"MSA2dist\", \n    \"msa\", \n    \"phangorn\", \n    \"seqinr\",\n    \"doubletrouble\",\n    \"feature\"\n)\n\nBiocManager::install(packages)\n\nAfter that, you should have everything ready."
  },
  {
    "objectID": "intro_to_R.html#goals-of-this-lesson",
    "href": "intro_to_R.html#goals-of-this-lesson",
    "title": "1  Introduction to R",
    "section": "1.1 Goals of this lesson",
    "text": "1.1 Goals of this lesson\nThis lesson was designed to be a gentle introduction to R for evolutionary genomics. Thus, we will only cover the basics of the language. An alternative name for this lesson could be “all you need to know about R to start your evolutionary analyses”. At the end of this lesson, you will be able to:\n\nperform simple mathematical operations in R\ncreate and modify objects\nuse functions and look for help\ncreate vectors and understand the difference between vector types\ncreate data frames\nsubset vectors and data frames"
  },
  {
    "objectID": "intro_to_R.html#creating-objects",
    "href": "intro_to_R.html#creating-objects",
    "title": "1  Introduction to R",
    "section": "1.2 Creating objects",
    "text": "1.2 Creating objects\nThe simplest use of R is to perform mathematical operations, which can be simply typed in the console:\n\n2 + 2\n\n[1] 4\n\n4 * 5\n\n[1] 20\n\n20 / 10\n\n[1] 2\n\n5 - 3\n\n[1] 2\n\n\nHowever, simple mathematical operations are not very useful. Typically, you would want to assign values to R objects. R objects can be created by using object_name + &lt;- + value. The &lt;- symbol is called the “assignment operator”, and it assigns values to objects. Example:\n\ngenome_size &lt;- 2000000\n\nNote that when you assign a value to an object, nothing happens on the screen. In the example above, we created an object named genome_size that contains the value 2000000, but the value is not printed to screen. To show the contents of an object, you must type its name and execute it. For example:\n\ngenome_size\n\n[1] 2e+06\n\n\nAlternatively, we can assign values to objects AND print them at the same time by surrounding the assignment code with parentheses. For example:\n\n(genome_size &lt;- 2000000)\n\n[1] 2e+06\n\n\n\n\n\n\n\n\nNaming objects\n\n\n\nAlthough you can give your objects whatever name you want, some general best practices include:\n\nChoose a descriptive name, but not too long.\nDo not use dots (.).\nUse nouns.\nBe consistent with your styling. Styles include snake case (e.g., phylo_tree) and camel case (e.g., phyloTree.)\n\nNote that object names cannot start with numbers.\n\n\nNow that we have an object genome_size with a value, we can use the object to perform mathematical operations. For example, let’s suppose we want to see the genome size in many thousands of base pairs (i.e., kbp, which stands for kilobase pairs):\n\ngenome_size / 1000\n\n[1] 2000\n\n\nWe can also change the value of an object by assigning a new value to it. For instance, let’s update the genome_size object with the size in kbp:\n\ngenome_size # original object\n\n[1] 2e+06\n\ngenome_size &lt;- genome_size / 1000 # modifying the object\ngenome_size\n\n[1] 2000\n\n\nAs you can see, the object genome_size now contains the value 2000."
  },
  {
    "objectID": "intro_to_R.html#functions-and-arguments",
    "href": "intro_to_R.html#functions-and-arguments",
    "title": "1  Introduction to R",
    "section": "1.3 Functions and arguments",
    "text": "1.3 Functions and arguments\nFunctions are scripts that automate a particular task, and they typically have verbs in their names. They are made available to users as part of packages, and there are several R packages with specialized functions for each field. When you download and install R, it already comes with some packages installed, such as base and utils, but you can also install other packages depending on your needs.\nA function takes one or many arguments as input and return something as output. To execute a function in R, you need to write the function name followed by the arguments inside parenthesis. For example, let’s execute the function sqrt(), which takes a numeric value as input and return its square root:\n\nsqrt(100)\n\n[1] 10\n\n\nYou can also pass objects as input to functions. For example, let’s pass our object genome_size to the sqrt() function:\n\nsqrt(genome_size)\n\n[1] 44.72136\n\n\nTo see all the possible arguments a function takes, use the function args() with the function name as input. For example, let’s see all possible arguments for the round() function (which rounds up numbers):\n\nargs(round)\n\nfunction (x, digits = 0) \nNULL\n\n\nWe can see that the round() function can take two arguments as input: x, which is a numeric value, and digits, which indicates how many digits should be used when rounding values. Let’s try to execute the round() function with different options to digits.\n\npi &lt;- 3.14159\nround(pi)\n\n[1] 3\n\nround(pi, digits = 2)\n\n[1] 3.14\n\nround(pi, digits = 3)\n\n[1] 3.142\n\n\nFinally, if you want to learn more about what a function does and how to use it, you can type the function name preceded by a question mark. For example:\n\n?round\n\nThis will open up a help page with detailed information on what the function does, its arguments, and examples.\n\n\n\n\n\n\nExercises\n\n\n\nThe genome of the plant Arabidopsis thaliana contains 33768 genes, of which 27655 are protein-coding and 6113 encode non-coding RNAs. Calculate the percentage of coding and non-coding genes in this genome using the following steps:\n\nCreate a variable named ath_genes that stores the numeric value 33768.\nCreate 2 objects named n_coding and n_noncoding that store the numeric values 27655 and 6113, respectively.\nCreate 2 objects named perc_coding and perc_noncoding by dividing n_coding and n_noncoding by ath_genes.\nUpdate the objects by multiplying their contents by 100 (to represent in percentages, from 0 to 100) and rounding the percentages to 1 significant digit only.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Store values in objects\nath_genes &lt;- 33768\nn_coding &lt;- 27655\nn_noncoding &lt;- 6113\n\n# Get percentages\nperc_coding &lt;- n_coding / ath_genes\nperc_noncoding &lt;- n_noncoding / ath_genes\n\n# Update objects with actual percentages\nperc_coding &lt;- round(perc_coding * 100, 1)\nperc_noncoding &lt;- round(perc_noncoding * 100, 1)\n\n# Show contents of the objects\nperc_coding\n\n[1] 81.9\n\nperc_noncoding\n\n[1] 18.1"
  },
  {
    "objectID": "intro_to_R.html#data-structures",
    "href": "intro_to_R.html#data-structures",
    "title": "1  Introduction to R",
    "section": "1.4 Data structures",
    "text": "1.4 Data structures\nNow, we will explore two data structures in R that we will use all the time throughout the lessons (and in our research routine): vectors and data frames.\n\n1.4.1 Vectors\nVector are the most common data structures in R, and they are used to store multiple values. There are 6 kinds of values that can be stored in a vector, but the ones we typically use are:\n\nnumeric: numbers.\ncharacter: text strings.\nlogical: either TRUE or FALSE.\n\nThe other types are integer, complex, and raw, but they are not important here.\nTo create a vector, you will use the c() function to combine values. For example:\n\n# Creating a numeric vector\ngenome_sizes &lt;- c(33768, 52872, 39756)\ngenome_sizes\n\n[1] 33768 52872 39756\n\n# Creating a character vector\nspecies &lt;- c(\"Arabidopsis\", \"soybean\", \"maize\")\nspecies\n\n[1] \"Arabidopsis\" \"soybean\"     \"maize\"      \n\n\nYou can inspect vectors with the functions:\n\nclass(): shows the class of a vector.\nlength(): shows the number of elements in a vector.\nstr(): summarizes the structure of a vector.\n\n\nclass(genome_sizes)\n\n[1] \"numeric\"\n\nlength(genome_sizes)\n\n[1] 3\n\nstr(genome_sizes)\n\n num [1:3] 33768 52872 39756\n\n\nYou can also combine two vectors:\n\nspecies1 &lt;- c(\"soybean\", \"maize\")\nspecies2 &lt;- c(\"cotton\", \"bean\")\ncombined_species &lt;- c(species1, species2)\ncombined_species\n\n[1] \"soybean\" \"maize\"   \"cotton\"  \"bean\"   \n\n\nNOTE: Vectors can only store values of the same type (i.e., character, numeric, etc). If you try to create a vector that contains values of different types, R converts them to all be the same type. This conversion of one class to another is called coercion. For example:\n\n# Creating a vector with numeric and character values\nc_vector &lt;- c(\"a\", \"b\", 1, \"d\")\nc_vector\n\n[1] \"a\" \"b\" \"1\" \"d\"\n\n\nIn the example above, R converted the numeric value 1 to a character.\n\n\n1.4.2 Data frames\nData frames is the name R uses to call tables. To create a new data frame, you will use the data.frame() function. Each column of a data frame is a vector, so you can create a data frame by passing each vector to each column. For example, let’s recreate the genome_sizes and species vectors we created in the previous section and store them in columns genome_size and species of a data frame:\n\n# Create vectors again\ngenome_sizes &lt;- c(33768, 52872, 39756)\nspecies &lt;- c(\"Arabidopsis\", \"soybean\", \"maize\")\n\n# Create a data frame with columns `genome_size` and `species`\ngenome_size_df &lt;- data.frame(\n    genome_size = genome_sizes,\n    species = species\n)\n\ngenome_size_df\n\n  genome_size     species\n1       33768 Arabidopsis\n2       52872     soybean\n3       39756       maize\n\n\nWe can also create the vectors inside the data.frame() function itself:\n\ngenome_size_df &lt;- data.frame(\n    genome_size = c(33768, 52872, 39756),\n    species = c(\"Arabidopsis\", \"soybean\", \"maize\")\n)\n\ngenome_size_df\n\n  genome_size     species\n1       33768 Arabidopsis\n2       52872     soybean\n3       39756       maize\n\n\nTo add a column to an existing data frame, you have to add $ followed by the new column name in front of the object name. For example, let’s add a column named is_model to the genome_size_df data frame that indicates whether or not a species is a model species:\n\n# Add `is_model` column\ngenome_size_df$is_model &lt;- c(TRUE, FALSE, FALSE)\ngenome_size_df\n\n  genome_size     species is_model\n1       33768 Arabidopsis     TRUE\n2       52872     soybean    FALSE\n3       39756       maize    FALSE\n\n\nFinally, to inspect a data frame, you can use the following functions:\n\ndim(): shows the dimensions of the data frame (i.e., number of rows and columns, respectively).\nnrow(): shows the number of rows in a data frame.\nncol(): shows the number of columns in a data frame.\nhead(): shows the first 6 rows of a data frame.\ntail(): shows the last 6 rows of a data frame.\nnames(): shows the column names.\nrownames(): shows the row names\nstr(): summarizes the structure of a data frame.\nsummary(): shows summary statistics for each column.\n\n\n\n\n\n\n\nExercises\n\n\n\n\nThe plants Brussels sprout, grapevine and apple belong to the families Brassicaceae, Vitaceae, and Rosaceae. Create a data frame named species_families with 2 columns named species and family representing such information.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nspecies_families &lt;- data.frame(\n    species = c(\"Brussels sprout\", \"grapevine\", \"apple\"),\n    family = c(\"Brassicaceae\", \"Vitaceae\", \"Rosaceae\")\n)\n\nspecies_families\n\n          species       family\n1 Brussels sprout Brassicaceae\n2       grapevine     Vitaceae\n3           apple     Rosaceae\n\n\n\n\n\n\nWhen you install R, it already comes with some example data sets. One of them is airquality, a data frame containing New York air quality measurements from May to September 1973. Inspect this data frame and answer the following questions:\n\nHow many rows are there?\nHow many columns are there?\nWhat are the column names?\nWhat are the classes of each column?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nstr(airquality)\n\n'data.frame':   153 obs. of  6 variables:\n $ Ozone  : int  41 36 12 18 NA 28 23 19 8 NA ...\n $ Solar.R: int  190 118 149 313 NA NA 299 99 19 194 ...\n $ Wind   : num  7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ...\n $ Temp   : int  67 72 74 62 56 66 65 59 61 69 ...\n $ Month  : int  5 5 5 5 5 5 5 5 5 5 ...\n $ Day    : int  1 2 3 4 5 6 7 8 9 10 ..."
  },
  {
    "objectID": "intro_to_R.html#indexing-and-subsetting",
    "href": "intro_to_R.html#indexing-and-subsetting",
    "title": "1  Introduction to R",
    "section": "1.5 Indexing and subsetting",
    "text": "1.5 Indexing and subsetting\nHere, you will learn how to extract specific elements of vectors and data frames, which is called subsetting.\n\n1.5.1 Vectors\nTo subset vectors, you need to pass the index of the element you want to extract inside square brackets ([]). If you want to extract multiple elements, you have to pass a vector of indices inside the square brackets. For example:\n\nplants &lt;- c(\"rice\", \"maize\", \"duckweed\")\n\n# Extract 1st element\nplants[1]\n\n[1] \"rice\"\n\n# Extract 1st and 2nd element\nplants[c(1, 2)]\n\n[1] \"rice\"  \"maize\"\n\n# Extract 3rd and 2nd element (in this order)\nplants[c(3, 2)]\n\n[1] \"duckweed\" \"maize\"   \n\n\nYou can also remove a given element by adding a minus (-) symbol before the index:\n\n# Get all elements, except the 1st\nplants[-1]\n\n[1] \"maize\"    \"duckweed\"\n\n# Get all elements, except the 1st and 3rd\nplants[-c(1, 3)]\n\n[1] \"maize\"\n\n\nAnother very common way to subset vectors is by using logical vectors. When using logical vectors, TRUE and FALSE will indicate whether to extract or not extract the element. For example, let’s use logical vectors to subset the plants vector we created above:\n\nplants\n\n[1] \"rice\"     \"maize\"    \"duckweed\"\n\n# Extract 1st element, do not extract 2nd and 3rd elements\nplants[c(TRUE, FALSE, FALSE)]\n\n[1] \"rice\"\n\n# Extract 1st and 3rd elements, do not extract 2nd\nplants[c(TRUE, FALSE, TRUE)]\n\n[1] \"rice\"     \"duckweed\"\n\n\nNow, you might be thinking: using logical vectors seems complicated. Why would someone do this instead of using indices?. The answer is conditional subsetting. In R, you can use logical expressions that return TRUE or FALSE to extract elements. For example, let’s create a vector of genome sizes for fictional species and check if they more than 20,000 genes:\n\nngenes &lt;- c(52000, 35000, 18000, 17000, 22000, 11000, 13000)\n\n# Logical expression: is the element &gt;= 20000?\nngenes &gt; 20000\n\n[1]  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE\n\n\nYou can see that the logical expression returns a vector of TRUEs and FALSEs. Since TRUE means extract and FALSE means do not extract when subsetting, we can use logical expressions to subset vectors as follows:\n\n# Extract elements with &gt;=20000 genes\nngenes[ngenes &gt; 20000]\n\n[1] 52000 35000 22000\n\n\nYou can combine multiple tests in logical expressions using & (which means AND, both conditions are true) and | (which means OR, at least one of the conditions is true).\n\n# Extract elements with number of genes between 20000 and 40000\nngenes[ngenes &gt; 20000 & ngenes &lt; 40000]\n\n[1] 35000 22000\n\n# Extract elements with 13000 or 11000 genes\nngenes[ngenes == 13000 | ngenes == 11000]\n\n[1] 11000 13000\n\n\nYou can also subset a vector based on the presence of some pre-defined elements using the %in% operator. For example:\n\nanimals &lt;- c(\"dog\", \"cat\", \"rat\", \"pig\", \"horse\")\n\nanimals[animals %in% c(\"cat\", \"dog\")]\n\n[1] \"dog\" \"cat\"\n\n\n\n\n1.5.2 Data frames\nSubsetting data frames in very similar to subsetting vectors. The only difference is that data frames have 2 dimensions (rows and columns), while vectors have only 1 dimension. Thus, when you subset a data frame, you have to specify which dimension you want to use. For instance, if you execute vec[2], you will extract the 2nd element of the vector vec. However, if you pass the index 2 to a data frame, you can mean either the 2nd row or the second column. To subset data frames, you will use commas (,) inside square brackets to distinguish rows (which come before the comma) from columns (which come after the comma. For example:\n\n# See the first 6 rows the `airquality` data frame\nhead(airquality)\n\n  Ozone Solar.R Wind Temp Month Day\n1    41     190  7.4   67     5   1\n2    36     118  8.0   72     5   2\n3    12     149 12.6   74     5   3\n4    18     313 11.5   62     5   4\n5    NA      NA 14.3   56     5   5\n6    28      NA 14.9   66     5   6\n\n# Extract the element in row 1, column 2\nairquality[1, 2]\n\n[1] 190\n\n# Extract rows 1 to 5, column 1 - note: `1:5` is the same as `c(1, 2, 3, 4, 5)`\nairquality[1:5, 1]\n\n[1] 41 36 12 18 NA\n\n\nTo extract all rows or all columns, leave the corresponding field empty:\n\n# Extract row 2, all columns\nairquality[2, ]\n\n  Ozone Solar.R Wind Temp Month Day\n2    36     118    8   72     5   2\n\n# Extract column 2, all rows\nairquality[, 2]\n\n  [1] 190 118 149 313  NA  NA 299  99  19 194  NA 256 290 274  65 334 307  78\n [19] 322  44   8 320  25  92  66 266  NA  13 252 223 279 286 287 242 186 220\n [37] 264 127 273 291 323 259 250 148 332 322 191 284  37 120 137 150  59  91\n [55] 250 135 127  47  98  31 138 269 248 236 101 175 314 276 267 272 175 139\n [73] 264 175 291  48 260 274 285 187 220   7 258 295 294 223  81  82 213 275\n [91] 253 254  83  24  77  NA  NA  NA 255 229 207 222 137 192 273 157  64  71\n[109]  51 115 244 190 259  36 255 212 238 215 153 203 225 237 188 167 197 183\n[127] 189  95  92 252 220 230 259 236 259 238  24 112 237 224  27 238 201 238\n[145]  14 139  49  20 193 145 191 131 223\n\n\nYou can also subset columns based on their names:\n\nairquality$Month\n\n  [1] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6\n [38] 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7\n [75] 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n[112] 8 8 8 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9\n[149] 9 9 9 9 9\n\nairquality[, \"Month\"] # same thing\n\n  [1] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6\n [38] 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7\n [75] 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n[112] 8 8 8 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9\n[149] 9 9 9 9 9\n\n\nAs we did with vectors, we can subset the data frame using logical expressions:\n\n# Extract rows for which column \"Month\" is equal to 5\nairquality[airquality$Month == 5, ]\n\n   Ozone Solar.R Wind Temp Month Day\n1     41     190  7.4   67     5   1\n2     36     118  8.0   72     5   2\n3     12     149 12.6   74     5   3\n4     18     313 11.5   62     5   4\n5     NA      NA 14.3   56     5   5\n6     28      NA 14.9   66     5   6\n7     23     299  8.6   65     5   7\n8     19      99 13.8   59     5   8\n9      8      19 20.1   61     5   9\n10    NA     194  8.6   69     5  10\n11     7      NA  6.9   74     5  11\n12    16     256  9.7   69     5  12\n13    11     290  9.2   66     5  13\n14    14     274 10.9   68     5  14\n15    18      65 13.2   58     5  15\n16    14     334 11.5   64     5  16\n17    34     307 12.0   66     5  17\n18     6      78 18.4   57     5  18\n19    30     322 11.5   68     5  19\n20    11      44  9.7   62     5  20\n21     1       8  9.7   59     5  21\n22    11     320 16.6   73     5  22\n23     4      25  9.7   61     5  23\n24    32      92 12.0   61     5  24\n25    NA      66 16.6   57     5  25\n26    NA     266 14.9   58     5  26\n27    NA      NA  8.0   57     5  27\n28    23      13 12.0   67     5  28\n29    45     252 14.9   81     5  29\n30   115     223  5.7   79     5  30\n31    37     279  7.4   76     5  31\n\n# Extract rows with \"Temp\" &gt;90, then show only columns \"Month\" and \"Day\"\nairquality[airquality$Temp &gt; 90, c(\"Month\", \"Day\")]\n\n    Month Day\n42      6  11\n43      6  12\n69      7   8\n70      7   9\n75      7  14\n102     8  10\n120     8  28\n121     8  29\n122     8  30\n123     8  31\n124     9   1\n125     9   2\n126     9   3\n127     9   4\n\n\n\n\n\n\n\n\nExercises\n\n\n\nSubset the airquality data set to answer the following questions:\n\nHow many days (rows) observations have ozone levels &gt;40 ppb?\nHow many days have wind speed between 10 and 15 mph?\nWhat are the minimum and maximum temperature?\nHow many days have solar radiation &lt;100 Langleys?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Q1: Ozone levels &gt;40 ppb\nnrow(airquality[airquality$Ozone &gt; 40, ])\n\n[1] 82\n\n# Q2: Wind speed between 10 and 15 mph\nnrow(airquality[airquality$Wind &gt;= 10 & airquality$Wind &lt;=15, ])\n\n[1] 62\n\n# Q3: Minimum and maximum temperature\nsummary(airquality)\n\n     Ozone           Solar.R           Wind             Temp      \n Min.   :  1.00   Min.   :  7.0   Min.   : 1.700   Min.   :56.00  \n 1st Qu.: 18.00   1st Qu.:115.8   1st Qu.: 7.400   1st Qu.:72.00  \n Median : 31.50   Median :205.0   Median : 9.700   Median :79.00  \n Mean   : 42.13   Mean   :185.9   Mean   : 9.958   Mean   :77.88  \n 3rd Qu.: 63.25   3rd Qu.:258.8   3rd Qu.:11.500   3rd Qu.:85.00  \n Max.   :168.00   Max.   :334.0   Max.   :20.700   Max.   :97.00  \n NA's   :37       NA's   :7                                       \n     Month            Day      \n Min.   :5.000   Min.   : 1.0  \n 1st Qu.:6.000   1st Qu.: 8.0  \n Median :7.000   Median :16.0  \n Mean   :6.993   Mean   :15.8  \n 3rd Qu.:8.000   3rd Qu.:23.0  \n Max.   :9.000   Max.   :31.0  \n                               \n\n# Q4: Solar radiation &lt;100 Langleys\nnrow(airquality[airquality$Solar.R &lt; 100, ])\n\n[1] 41"
  },
  {
    "objectID": "data_structures_genomics.html#goals-of-this-lesson",
    "href": "data_structures_genomics.html#goals-of-this-lesson",
    "title": "2  R for evolutionary biology: data structures",
    "section": "2.1 Goals of this lesson",
    "text": "2.1 Goals of this lesson\nIn this lesson, you will learn to:\n\nrepresent and work with sequence data using XString and XStringSet objects\nrepresent and work with multiple sequence alignments using XMultipleAlignment objects\nrepresent and work with phylogenies using phylo objects"
  },
  {
    "objectID": "data_structures_genomics.html#the-bioconductor-ecosystem",
    "href": "data_structures_genomics.html#the-bioconductor-ecosystem",
    "title": "2  R for evolutionary biology: data structures",
    "section": "2.2 The Bioconductor ecosystem",
    "text": "2.2 The Bioconductor ecosystem\nThe Bioconductor project was created to develop, support, and disseminate free open source software to analyze biological data. It works as a repository of R packages for biological data analysis, with both “core packages” (developed and maintained by the Bioconductor Core Team), and community-contributed packages. We usually refer to Bioconductor as a “package ecosystem” because its packages are tightly integrated and designed for easy interoperation, such that different packages can be used together with minimal effort. An important facilitator of such interoperability is the existence of standardized data structures, such as GRanges objects for genomic coordinates, and DNA/RNA/AAStringSet objects for sequences.\n\n2.2.1 The {Biostrings} package and XStringSet objects\nThe Biostrings package (Pagès et al. 2022) allows efficient manipulation of biological sequences, and its data classes are standard for all Bioconductor packages that involve sequence analyses. The data classes in Biostrings to represent sets of biological sequences are:\n\nDNAStringSet: for sets of DNA strings.\nRNAStringSet: for sets of RNA strings.\nAAStringSet: for sets of amino acid strings.\n\nFor a single sequence, the each of the above has a correspoding XString class (i.e., DNAString, RNAString, AAString). For example, let’s create some XString objects manually:\n\nlibrary(Biostrings)\n\n# Create `DNAString` object\ndna_seq &lt;- DNAString(\"ATGGCCGACTCA\")\ndna_seq\n\n12-letter DNAString object\nseq: ATGGCCGACTCA\n\n# Convert `DNAString` to `RNAString`\nrna_seq &lt;- RNAString(dna_seq)\nrna_seq\n\n12-letter RNAString object\nseq: AUGGCCGACUCA\n\n# Translate `RNAString` to create `AAString`\naa_seq &lt;- translate(rna_seq)\naa_seq\n\n4-letter AAString object\nseq: MADS\n\n\nIn real-world data analyses, we would work with multiple sequences (e.g., a whole genome or a whole proteome). Multiple sequences are stored in XStringSet objects, which can be read from FASTA files with readXStringSet() functions, namely:\n\nreadDNAStringSet(): read FASTA file containing multiple DNA sequences.\nreadRNAStringSet(): read FASTA file containing multiple RNA sequences.\nreadAAStringSet(): read FASTA file containing multiple AA sequences.\n\nFor example, let’s read an example FASTA file that come with the Biostrings package.\n\n# Path to FASTA file containing an ORF\nfasta_file &lt;- system.file(\"extdata\", \"someORF.fa\", package = \"Biostrings\")\nfasta_file\n\n[1] \"/home/runner/work/_temp/Library/Biostrings/extdata/someORF.fa\"\n\n# Read FASTA file as a DNAStringSet object\ndna_seqs &lt;- readDNAStringSet(fasta_file)\ndna_seqs\n\nDNAStringSet object of length 7:\n    width seq                                               names               \n[1]  5573 ACTTGTAAATATATCTTTTATTT...CTTATCGACCTTATTGTTGATAT YAL001C TFC3 SGDI...\n[2]  5825 TTCCAAGGCCGATGAATTCGACT...AGTAAATTTTTTTCTATTCTCTT YAL002W VPS8 SGDI...\n[3]  2987 CTTCATGTCAGCCTGCACTTCTG...TGGTACTCATGTAGCTGCCTCAT YAL003W EFB1 SGDI...\n[4]  3929 CACTCATATCGGGGGTCTTACTT...TGTCCCGAAACACGAAAAAGTAC YAL005C SSA1 SGDI...\n[5]  2648 AGAGAAAGAGTTTCACTTCTTGA...ATATAATTTATGTGTGAACATAG YAL007C ERP2 SGDI...\n[6]  2597 GTGTCCGGGCCTCGCAGGCGTTC...AAGTTTTGGCAGAATGTACTTTT YAL008W FUN14 SGD...\n[7]  2780 CAAGATAATGTCAAAGTTAGTGG...GCTAAGGAAGAAAAAAAAATCAC YAL009W SPO7 SGDI...\n\n\nSome examples of what you can do to explore XStringSet objects include:\n\n# width(): get sequence lengths\nwidth(dna_seqs)\n\n[1] 5573 5825 2987 3929 2648 2597 2780\n\n# names(): get sequence names\nnames(dna_seqs)\n\n[1] \"YAL001C TFC3 SGDID:S0000001, Chr I from 152168-146596, reverse complement, Verified ORF\"\n[2] \"YAL002W VPS8 SGDID:S0000002, Chr I from 142709-148533, Verified ORF\"                    \n[3] \"YAL003W EFB1 SGDID:S0000003, Chr I from 141176-144162, Verified ORF\"                    \n[4] \"YAL005C SSA1 SGDID:S0000004, Chr I from 142433-138505, reverse complement, Verified ORF\"\n[5] \"YAL007C ERP2 SGDID:S0000005, Chr I from 139347-136700, reverse complement, Verified ORF\"\n[6] \"YAL008W FUN14 SGDID:S0000006, Chr I from 135916-138512, Verified ORF\"                   \n[7] \"YAL009W SPO7 SGDID:S0000007, Chr I from 134856-137635, Verified ORF\"                    \n\n# subset DNAStringSet and create a DNAStringSet of length 1\ndna_seqs[1]\n\nDNAStringSet object of length 1:\n    width seq                                               names               \n[1]  5573 ACTTGTAAATATATCTTTTATTT...CTTATCGACCTTATTGTTGATAT YAL001C TFC3 SGDI...\n\n# subset DNAStringSet and create a DNAString object\ndna_seqs[[1]]\n\n5573-letter DNAString object\nseq: ACTTGTAAATATATCTTTTATTTTCCGAGAGGAAAA...AATTTCTTAAACGCTTATCGACCTTATTGTTGATAT\n\n\nAll functions above would also work for AAStringSet objects and RNAStringSet objects.\n\n\n\n\n\n\nExercises\n\n\n\nUse the dna_seqs object created above to answer the following questions:\n\nWhat is the length of the 3rd sequence?\nWhat is the name of the 5th sequence?\nHow many times does the TTCC sequence string occur in each sequence? Hint: use the function vcountPattern().\nWhat are the first 3 nucleotides of each sequence? Hint: use the subseq() function.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Q1: Length of the 3rd sequence\nwidth(dna_seqs)[3]\n\n[1] 2987\n\n# Q2: Name of the 5th sequence\nnames(dna_seqs)[5]\n\n[1] \"YAL007C ERP2 SGDID:S0000005, Chr I from 139347-136700, reverse complement, Verified ORF\"\n\n# Q3: Minimum and maximum temperature\nvcountPattern(\"TTCC\", dna_seqs)\n\n[1] 21 28 16 23 15  8  5\n\n# Q4: First 3 nucleotides of each sequence\nsubseq(dna_seqs, start = 1, end = 3)\n\nDNAStringSet object of length 7:\n    width seq                                               names               \n[1]     3 ACT                                               YAL001C TFC3 SGDI...\n[2]     3 TTC                                               YAL002W VPS8 SGDI...\n[3]     3 CTT                                               YAL003W EFB1 SGDI...\n[4]     3 CAC                                               YAL005C SSA1 SGDI...\n[5]     3 AGA                                               YAL007C ERP2 SGDI...\n[6]     3 GTG                                               YAL008W FUN14 SGD...\n[7]     3 CAA                                               YAL009W SPO7 SGDI...\n\n\n\n\n\n\n\n\n\n2.2.2 The {Biostrings} package and XMultipleAlignment objects\nLike XStringSet objects, XMultipleAlignment objects also store sequences, but sequences that were aligned using a Sequence Alignment algorithm. FASTA files containing aligned sequences can be read with XMultipleAlignment functions, namely:\n\nreadDNAMultipleAlignment(): read a FASTA file containing aligned DNA sequences.\nreadRNAMultipleAlignment(): read a FASTA file containing aligned RNA sequences.\nreadAAMultipleAlignment(): read a FASTA file containing aligned amino acid sequences.\n\nFor example:\n\n# Path to FASTA file containing MSA of DNA sequences\naln_path &lt;- system.file(\"extdata\", \"msx2_mRNA.aln\", package = \"Biostrings\")\naln_path\n\n[1] \"/home/runner/work/_temp/Library/Biostrings/extdata/msx2_mRNA.aln\"\n\n# Read MSA file\ndna_msa &lt;- readDNAMultipleAlignment(aln_path)\ndna_msa\n\nDNAMultipleAlignment with 8 rows and 2343 columns\n     aln                                                    names               \n[1] -----TCCCGTCTCCGCAGCAAAAAA...TCACAATTAAAAAAAAAAAAAAAAA gi|84452153|ref|N...\n[2] --------------------------...------------------------- gi|208431713|ref|...\n[3] --------------------------...------------------------- gi|118601823|ref|...\n[4] ----------------------AAAA...------------------------- gi|114326503|ref|...\n[5] --------------------------...------------------------- gi|119220589|ref|...\n[6] --------------------------...------------------------- gi|148540149|ref|...\n[7] --------------CGGCTCCGCAGC...------------------------- gi|45383056|ref|N...\n[8] GGGGGAGACTTCAGAAGTTGTTGTCC...------------------------- gi|213515133|ref|...\n\n\n\n\n\n\n\n\nExercises\n\n\n\nWhat is the consensus sequence of the multiple sequence alignment in dna_msa? Hint: use the consensusString() function.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nconsensusString(dna_msa)\n\n[1] \"----------------------VWVMKYYBSRSTSDYVVMDKBHSVGHKSMSVRYVKDRYHRHKVSBYDNVVRVYWMSYNGVRCRGABAMGTCA-YRGCTTCTCYGTSCAWAGGCRRTGRCYTGTTYTCGYCCRRYGARGAGGGCCCVGCRGTKSTSGCCSGMCSRGGCCCVGGGCCYGGRGGMGCCGAGGGVGSCGMRGAGGAGCRCMRSGTCAAGGTCTCCAGCYTGCCCTTCAGYGTGGAGGCGCTCATGTCSGACAAGAARCCGCCYAAGGARKCGYCSSCGSKGCCRSCCGAMWGCGSCTCSGCYGGSGCYRYCCTGSGG----CCR-----CTGCTGCTGYCGGGVCACGGCGYYCGG-GAMGCKCMCAGYCCC---GGGCCKCTSGTSAARMCCTTCGAGACCGCCTCGGTCAAGTCGGARAAYTCMGARGAYGGARCGBCGTGGATVCAGGARCCCGGCMGATAYTCSCCKCCGCCMAGACAYATGAGCCCYACMRCCTGCACCCTGMGGAARCACAAGACCAAYCGGAAGCCVCGCACVCCCTTYACCACRTCCCAGCTYCTVGCCYTGGAGCGCAAGTTCCGYCAGAAACAGTACCTSTCCATYGCAGAGCGKGCMGAGTTCTCCAGCTCYCTGAACCTYACAGAGACCCAGGTCAAAATCTGGTTCCARAAYCGAAGGGCYAAGGCSAARAGACTGCAGGAGGCRGARCTRGARAAGCTSAARATGGCTGCMAARCCTATGYTGCCCTCVRGCTTCAGYCTBCCYTTCCCYATCARCTCSCCCYTGCARGCRGCRTCCMTATAYGGMRCRTCYTACCCBTTYCATAGACCTGTGC---TYCCYATCCCGCCYGT-BGGACTCTATGCSACBCCRGTSGGATATRGCATGTACCAYCTRTCCTAAGGAAGACCAGATSRRY-MGACTCCAGGATGGRTGWYTGYYTRAWAGMMTYYCCCNTCCMKCTYCRAGAAKGCRGTRCCAAYYY-TRSWMCTGMA-YGCWARCYYTGCRT-YGTCACCCTAASCRDCWRGGCTG--RCAGGRCYACWYGAYAYAGADBVAATTTGTTMTKTAGGYRRSAGRCACY-AAGMCYKGKTTTSTTKKYATARTYYYCYRRRTGC--CCCCTTTTCCYYTCASARW-KATTGGCTCTGMTAGTTTTTATGTATAAATATATA------ATAAAATATAAKAC--TTTTTATAYRSCARATGTAAAAATTCAAVYTRTKYTRDAW--GSCAAARTTTRTWKRHWYRYKTVBYHDKWTW---------YVTRKVTMDSMTYHYYHHMWRAHWHYSWGW-WAGYYC---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\""
  },
  {
    "objectID": "data_structures_genomics.html#the-ape-package-and-phylo-objects",
    "href": "data_structures_genomics.html#the-ape-package-and-phylo-objects",
    "title": "2  R for evolutionary biology: data structures",
    "section": "2.3 The {ape} package and phylo objects",
    "text": "2.3 The {ape} package and phylo objects\nThe ape package (Paradis and Schliep 2019) is one of the most popular packages for Analyses of Phylogenetics and Evolution (from where the name comes), and it represents phylogenies as phylo objects. Because of ape’s popularity, phylo objects have become the standard data structure for phylogenies in R.\nTo create phylo objects, you will use the function read.tree(), which accepts both the path to a file containing the tree (in Newick format, for example), or a text representation of a phylogeny. To demonstrate the structure of a phylo object, let’s create a phylogeny from text:\n\nlibrary(ape)\n\n# Create tree from text\ntext_tree &lt;- \"((((cow, pig),whale), (bat, (lemur, human))), iguana);\"\ntree &lt;- read.tree(text = text_tree)\n\ntree\n\n\nPhylogenetic tree with 7 tips and 6 internal nodes.\n\nTip labels:\n  cow, pig, whale, bat, lemur, human, ...\n\nRooted; no branch lengths.\n\n\nThis is what a phylo object looks like. In a sense, a phylo object is a list, a standard R data structure, but with some standard elements. Let’s explore them:\n\n# Structure of the `phylo` object\nstr(tree)\n\nList of 3\n $ edge     : int [1:12, 1:2] 8 9 10 11 11 10 9 12 12 13 ...\n $ Nnode    : int 6\n $ tip.label: chr [1:7] \"cow\" \"pig\" \"whale\" \"bat\" ...\n - attr(*, \"class\")= chr \"phylo\"\n - attr(*, \"order\")= chr \"cladewise\"\n\n# Exploring each element individually\ntree$edge\n\n      [,1] [,2]\n [1,]    8    9\n [2,]    9   10\n [3,]   10   11\n [4,]   11    1\n [5,]   11    2\n [6,]   10    3\n [7,]    9   12\n [8,]   12    4\n [9,]   12   13\n[10,]   13    5\n[11,]   13    6\n[12,]    8    7\n\ntree$Nnode\n\n[1] 6\n\ntree$tip.label\n\n[1] \"cow\"    \"pig\"    \"whale\"  \"bat\"    \"lemur\"  \"human\"  \"iguana\"\n\n\nAs phylo objects have become standard, there are hundreds of functions (from dozens of packages) that were especially designed to work on phylo objects. For example, if you want to plot the tree, you would use the plot() function:\n\n# Plot tree\nplot(tree)\n\n\n\n\nWe will explore other examples in future lessons.\n\n\n\n\n\n\nExercises\n\n\n\nUse the following code to simulate a random tree and answer the questions below:\n\nset.seed(123) # for reproducibility\nsim_tree &lt;- rtree(n = 20)\n\n\nHow many terminal taxa (i.e., tips) are there?\nWhat the the names of terminal taxa?\nWhat taxon is more closely-related to the taxon “t1”?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Q1: Number of terminal taxa\nNtip(sim_tree)\n\n[1] 20\n\n# Q2: Names of terminal taxa\nsim_tree$tip.label\n\n [1] \"t5\"  \"t19\" \"t9\"  \"t3\"  \"t8\"  \"t10\" \"t7\"  \"t15\" \"t18\" \"t17\" \"t4\"  \"t1\" \n[13] \"t11\" \"t14\" \"t20\" \"t13\" \"t16\" \"t2\"  \"t12\" \"t6\" \n\n# Q3: Visualizing the tree to check who is more closely-related to 't1'\nplot(sim_tree)"
  },
  {
    "objectID": "data_structures_genomics.html#references",
    "href": "data_structures_genomics.html#references",
    "title": "2  R for evolutionary biology: data structures",
    "section": "References",
    "text": "References\n\n\n\n\nPagès, H., P. Aboyoun, R. Gentleman, and S. DebRoy. 2022. Biostrings: Efficient Manipulation of Biological Strings. https://bioconductor.org/packages/Biostrings.\n\n\nParadis, Emmanuel, and Klaus Schliep. 2019. “Ape 5.0: An Environment for Modern Phylogenetics and Evolutionary Analyses in R.” Bioinformatics 35: 526–28. https://doi.org/10.1093/bioinformatics/bty633."
  },
  {
    "objectID": "phylogeny_inference_distance.html#goals-of-this-lesson",
    "href": "phylogeny_inference_distance.html#goals-of-this-lesson",
    "title": "3  Distance-based phylogeny inference",
    "section": "3.1 Goals of this lesson",
    "text": "3.1 Goals of this lesson\nIn this lesson, you will learn to:\n\nperform MSA\ncalculate distances from MSA\ninfer phylogenetic trees from distance matrices"
  },
  {
    "objectID": "phylogeny_inference_distance.html#multiple-sequence-alignment-msa",
    "href": "phylogeny_inference_distance.html#multiple-sequence-alignment-msa",
    "title": "3  Distance-based phylogeny inference",
    "section": "3.2 Multiple Sequence Alignment (MSA)",
    "text": "3.2 Multiple Sequence Alignment (MSA)\nThere are several algorithms to perform an MSA, such as ClustalW (Thompson, Higgins, and Gibson 1994), ClustalOmega (Sievers et al. 2011), MUSCLE (Edgar 2004), and MAFFT (Katoh and Standley 2013). Comparing them and deciding which one is the best is beyond the scope of this lesson. Here, we will perform MSA with the Bioconductor package msa (Bodenhofer et al. 2015), which provides native implementations of the ClustalW, ClustalOmega, and MUSCLE algorithms.\nmsa comes with an example FASTA file containing protein sequences of hemoglobin subunit alpha 1 in multiple species. Let’s start by reading the example file:\n\nlibrary(msa)\nlibrary(Biostrings)\n\n# Path to example file\nfasta_path &lt;- system.file(\"examples\", \"HemoglobinAA.fasta\", package=\"msa\")\nfasta_path\n\n[1] \"/home/runner/work/_temp/Library/msa/examples/HemoglobinAA.fasta\"\n\n# Read example file\nhemoglobin_seqs &lt;- readAAStringSet(fasta_path)\nhemoglobin_seqs\n\nAAStringSet object of length 17:\n     width seq                                              names               \n [1]   141 VLSPADKTNVKAAWGKVGAHAGE...AVHASLDKFLASVSTVLTSKYR HBA1_Homo_sapiens\n [2]   141 VLSPADKSNVKAAWGKVGGHAGE...AVHASLDKFLASVSTVLTSKYR HBA1_Macaca_mulatta\n [3]   141 MLTDAEKKEVTALWGKAAGHGEE...SAHAAMDKFLSKVATVLTSKYR HBA1_Ornithorhync...\n [4]   141 VLSAADKGNVKAAWGKVGGHAAE...AVHASLDKFLANVSTVLTSKYR HBA1_Bos_taurus\n [5]   141 VLSAADKTNVKAAWSKVGGNSGA...EIHASLDKFLALLSTVLTSKYR HBA1_Monodelphis_...\n ...   ... ...\n[13]   141 VLSPADKTNVKGTWSKIGNHSAE...SVHASLDKFLASVSTVLTSKYR HBA1_Tursiops_tru...\n[14]   141 HLTADDKKHIKAIWPSVAAHGDK...ATHKALDKFLVSVSNVLTSKYR HBA1_Xenopus_trop...\n[15]   141 VLTEEDKARVRVAWVPVSKNAEL...EVLLSVDKFLGQISKVLASRYR HBA1_Microcephalo...\n[16]   142 MVLSPADKTNVKAAWGKVGAHAG...AVHASLDKFLASVSTVLTSKYR HBA1_Pan_troglodytes\n[17]   142 MVLSADDKTNIKNCWGKIGGHGG...AMHASLDKFLASVSTVLTSKYR HBA1_Rattus_norve...\n\n\nNow, we will use the function msa() to perform an MSA using the default algorithm (ClustalW). You can also use other algorithms by changing the argument passed to the method parameter.\n\n# Perform MSA\nhemoglobin_aln &lt;- msa(hemoglobin_seqs)\n\nuse default substitution matrix\n\nhemoglobin_aln\n\nCLUSTAL 2.1  \n\nCall:\n   msa(hemoglobin_seqs)\n\nMsaAAMultipleAlignment with 17 rows and 143 columns\n     aln                                                   names\n [1] -VLSPADKTNVKAAWGKVGAHAGEY...FTPAVHASLDKFLASVSTVLTSKYR HBA1_Homo_sapiens\n [2] MVLSPADKTNVKAAWGKVGAHAGEY...FTPAVHASLDKFLASVSTVLTSKYR HBA1_Pan_troglodytes\n [3] -VLSPADKSNVKAAWGKVGGHAGEY...FTPAVHASLDKFLASVSTVLTSKYR HBA1_Macaca_mulatta\n [4] -VLSAADKGNVKAAWGKVGGHAAEY...FTPAVHASLDKFLANVSTVLTSKYR HBA1_Bos_taurus\n [5] -VLSPADKTNVKGTWSKIGNHSAEY...FTPSVHASLDKFLASVSTVLTSKYR HBA1_Tursiops_tru...\n [6] -VLSGEDKSNIKAAWGKIGGHGAEY...FTPAVHASLDKFLASVSTVLTSKYR HBA1_Mus_musculus\n [7] MVLSADDKTNIKNCWGKIGGHGGEY...FTPAMHASLDKFLASVSTVLTSKYR HBA1_Rattus_norve...\n [8] -VLSATDKANVKTFWGKLGGHGGEY...FTPAVHASLDKFLATVATVLTSKYR HBA1_Erinaceus_eu...\n [9] -VLSAADKSNVKACWGKIGSHAGEY...FTPAVHASLDKFFSAVSTVLTSKYR HBA1_Felis_silves...\n[10] -VLSPADKTNIKSTWDKIGGHAGDY...FTPAVHASLDKFFTAVSTVLTSKYR HBA1_Chrysocyon_b...\n[11] -VLSDNDKTNVKATWSKVGDHASDY...FTPEVHASLDKFLSNVSTVLTSKYR HBA1_Loxodonta_af...\n[12] -VLSAADKTNVKAAWSKVGGNSGAY...FTPEIHASLDKFLALLSTVLTSKYR HBA1_Monodelphis_...\n[13] -MLTDAEKKEVTALWGKAAGHGEEY...FTPSAHAAMDKFLSKVATVLTSKYR HBA1_Ornithorhync...\n[14] -VLSAADKNNVKGIFTKIAGHAEEY...LTPEVHASLDKFLCAVGTVLTAKYR HBA1_Gallus_gallus\n[15] -HLTADDKKHIKAIWPSVAAHGDKY...FDPATHKALDKFLVSVSNVLTSKYR HBA1_Xenopus_trop...\n[16] -VLTEEDKARVRVAWVPVSKNAELY...LKPEVLLSVDKFLGQISKVLASRYR HBA1_Microcephalo...\n[17] -SLSDTDKAVVKAIWAKISPKADEI...FTPEVHVSVDKFFNNLALALSEKYR HBA1_Danio_rerio\n Con -VLS?ADK?NVKA?WGK?GGHA?EY...FTPAVHASLDKFLA?VSTVLTSKYR Consensus \n\n\nNow that we have an MSA, we can calculate distances."
  },
  {
    "objectID": "phylogeny_inference_distance.html#calculating-distance-matrices",
    "href": "phylogeny_inference_distance.html#calculating-distance-matrices",
    "title": "3  Distance-based phylogeny inference",
    "section": "3.3 Calculating distance matrices",
    "text": "3.3 Calculating distance matrices\nHere, we will calculate distance matrices using 2 different methods:\n\nthe aastring2dist() function from MSA2dist, which calculates distances from AAStringSet objects using a score matrix. Here, we will use the Grantham matrix (Grantham 1974).\nthe dist.alignment() function from seqinr, which calculates distances from alignment objects using a similarity or identity matrix. Here, we will use the identity matrix.\n\nFirst, as these 2 functions take different data classes as input, we will have to convert the hemoglobin_aln object to the right classes for each function.\n\n# Convert `MsaAAMultipleAlignment` to `AAStringSet` for MSA2dist\naln_msa2dist &lt;- as(hemoglobin_aln, \"AAStringSet\")\n\n# Convert `MsaAAMultipleAlignment` to `alignment` for seqinr\naln_seqinr &lt;- msaConvert(hemoglobin_aln, type = \"seqinr::alignment\")\n\nNow, we can calculate the distance matrices.\n\nlibrary(MSA2dist)\nlibrary(seqinr)\n\n# Calculate distance matrix with `MSA2dist::aastring2dist()`\ndist_matrix1 &lt;- aastring2dist(aa = aln_msa2dist, score = granthamMatrix())\n\n\nComputing: [========================================] 100% (done)                         \n\ndist_matrix1 &lt;- as.dist(dist_matrix1$distSTRING)\n\n\n# Calculate distance matrix with `seqinr::dist.alignment()`\ndist_matrix2 &lt;- dist.alignment(aln_seqinr, matrix = \"identity\")\n\n\n# Inspect distance matrices\nhead(dist_matrix1)\n\n[1]  0.000000  2.347518  9.035461  9.446809  8.304965 15.702128\n\nhead(dist_matrix2)\n\n[1] 0.0000000 0.1684304 0.3472281 0.4038819 0.3766218 0.4688903\n\nclass(dist_matrix1)\n\n[1] \"dist\"\n\nclass(dist_matrix2)\n\n[1] \"dist\"\n\n\nAs you can see, distance matrices are stored in objects of class dist. This is the data class that we will use to infer phylogenetic trees."
  },
  {
    "objectID": "phylogeny_inference_distance.html#inferring-trees",
    "href": "phylogeny_inference_distance.html#inferring-trees",
    "title": "3  Distance-based phylogeny inference",
    "section": "3.4 Inferring trees",
    "text": "3.4 Inferring trees\nNow, we will use the bionjs() function from ape to infer neighbor-joining trees using the two distance matrices we calculated in the previous section.\n\nlibrary(ape)\n\n# Infer neighbor-joining trees\ntree1 &lt;- bionjs(dist_matrix1)\ntree2 &lt;- bionjs(dist_matrix2)\n\n# Plotting trees\nplot(tree1)\n\n\n\nplot(tree2)\n\n\n\n\nThe two methods lead to different tree topologies. How do you know which one is “true”, then? This is the topic of the next lesson, where you will learn how to use maximum likelihood to assess trees.\n\n\n\n\n\n\nExercises\n\n\n\nUse the dist_matrix1 object to infer a phylogeny using the upgma() function from the phangorn package (Schliep 2011). Is the topology the same as the topology of tree1?\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Infer UPGMA tree and compare topologies\ntree_upgma &lt;- phangorn::upgma(dist_matrix1)\nplot(tree_upgma)"
  },
  {
    "objectID": "phylogeny_inference_distance.html#references",
    "href": "phylogeny_inference_distance.html#references",
    "title": "3  Distance-based phylogeny inference",
    "section": "References",
    "text": "References\n\n\n\n\nBodenhofer, Ulrich, Enrico Bonatesta, Christoph Horejš-Kainrath, and Sepp Hochreiter. 2015. “Msa: An r Package for Multiple Sequence Alignment.” Bioinformatics 31 (24): 3997–99.\n\n\nEdgar, Robert C. 2004. “MUSCLE: Multiple Sequence Alignment with High Accuracy and High Throughput.” Nucleic Acids Research 32 (5): 1792–97.\n\n\nGrantham, Richard. 1974. “Amino Acid Difference Formula to Help Explain Protein Evolution.” Science 185 (4154): 862–64.\n\n\nKatoh, Kazutaka, and Daron M Standley. 2013. “MAFFT Multiple Sequence Alignment Software Version 7: Improvements in Performance and Usability.” Molecular Biology and Evolution 30 (4): 772–80.\n\n\nSchliep, K. P. 2011. “Phangorn: Phylogenetic Analysis in r.” Bioinformatics 27 (4): 592–93. https://doi.org/10.1093/bioinformatics/btq706.\n\n\nSievers, Fabian, Andreas Wilm, David Dineen, Toby J Gibson, Kevin Karplus, Weizhong Li, Rodrigo Lopez, et al. 2011. “Fast, Scalable Generation of High-Quality Protein Multiple Sequence Alignments Using Clustal Omega.” Molecular Systems Biology 7 (1): 539.\n\n\nThompson, Julie D, Desmond G Higgins, and Toby J Gibson. 1994. “CLUSTAL w: Improving the Sensitivity of Progressive Multiple Sequence Alignment Through Sequence Weighting, Position-Specific Gap Penalties and Weight Matrix Choice.” Nucleic Acids Research 22 (22): 4673–80."
  },
  {
    "objectID": "phylogeny_inference_ml.html#goals-of-this-lesson",
    "href": "phylogeny_inference_ml.html#goals-of-this-lesson",
    "title": "4  Maximum likelihood-based phylogeny inference",
    "section": "4.1 Goals of this lesson",
    "text": "4.1 Goals of this lesson\nTo demonstrate how to use IQ-TREE, we will use an example data set to explore a question that used to be hotly debated years ago:\n\nAre turtles more closely-related to birds or to crocodiles?\n\nThere are 3 hypotheses to test, and here we will use maximum-likelihood-based methods to find out which one is true:\n\n\n\n\n\nIn this lesson, you will learn to:\n\nInfer a maximum likelihood tree\nApply partition models and choose the best partitioning schemes\nPerform tree topology tests\nIdentify and remove influential genes\nCalculate concordance factors"
  },
  {
    "objectID": "phylogeny_inference_ml.html#data-description",
    "href": "phylogeny_inference_ml.html#data-description",
    "title": "4  Maximum likelihood-based phylogeny inference",
    "section": "4.2 Data description",
    "text": "4.2 Data description\nThe data we will use in this lesson were obtained from Chiari et al. (2012), and they are stored in the data/ directory associated with this course. The files we will use are:\n\nturtle.fa: a multiple sequence alignment (in FASTA) of a subset of the genes used in the original publication.\nturtle.nex: a partition file (in NEXUS) defining a subset of 29 genes."
  },
  {
    "objectID": "phylogeny_inference_ml.html#inferring-a-maximum-likelihood-tree",
    "href": "phylogeny_inference_ml.html#inferring-a-maximum-likelihood-tree",
    "title": "4  Maximum likelihood-based phylogeny inference",
    "section": "4.3 Inferring a maximum likelihood tree",
    "text": "4.3 Inferring a maximum likelihood tree\nTo run IQ-TREE, use the command below:\n\niqtree2 -s data/turtle.fa -B 1000 -T 2\n\n\n\n\n\n\n\nUnderstanding the command-line arguments\n\n\n\nThe argument -s is mandatory, and this is where you indicate where the file containing the MSA is. In our previous command, iqtree2 -s data/turtle.fa means “run IQ-TREE using the MSA in the file data/turtle.fa”.\nThe other arguments and their meanings are:\n\n-B: number of replicates for the ultrafast bootstrap (see Minh, Nguyen, and Von Haeseler (2013) for details). Here, we used 1000 replicates.\n-T: number of CPU cores to use. Here, we’re using 2 cores, because IQ-TREE defaults to using all available cores.\n\nFor a complete list of arguments and the possible values they take, run iqtree2 -h.\n\n\nThe main IQ-TREE report will be stored in a file ending in .iqtree, and the maximum likelihood tree (in Newick format) will be stored in a file ending in .treefile.\n\n\n\n\n\n\nExercises\n\n\n\n\nLook at the report file in data/turtle.fa.iqtree and answer the questions below. Hint: you can use the readLines() function to read the output to the R session.\n\nWhat is the best-fit model name?\nWhat are the AIC/AICc/BIC scores of this model and tree?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Read file\nturtle_report &lt;- readLines(here(\"data\", \"turtle.fa.iqtree\"))\n\n# Q1: Best-fit model\nturtle_report[grepl(\"Best-fit model\", turtle_report)]\n\n[1] \"Best-fit model according to BIC: GTR+F+R3\"\n\n# Q2: AIC/AICc/BIC scores for the best model\nturtle_report[grepl(\"^Model  |^GTR\\\\+F\\\\+R3\", turtle_report)]\n\n[1] \"Model                  LogL         AIC      w-AIC        AICc     w-AICc         BIC      w-BIC\"\n[2] \"GTR+F+R3        -116218.179  232518.358 - 0.000395  232518.524 - 0.000398  232844.049 +    0.527\"\n\n\n\n\n\n\nVisualise the tree in data/turtle.fa.treefile. What relationship among three trees does this tree support? What is the ultrafast bootstrap support (%) for the relevant clade?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ntree &lt;- read.tree(here(\"data\", \"turtle.fa.treefile\"))\n\nplot(tree, show.node.label = TRUE)\n\n\n\n\nThis tree supports the “C” hypothesis, which positions turtles as a sister group to crocodiles. i.e., ((Turtle, Crocodile), Bird). The branch showing that turtles are a sister group to crocodiles has a bootstrap support of 82%.\n\n\n\n\nIn the figure below, you can see the tree published by Chiari et al. (2012). Does the inferred tree agree with the published tree?\n\n\n\n\nSpecies tree inferred by Chiari et al, 2012\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nNo. The published tree shows turtles as a sister group to birds and crocodiles (hypothesis A), while the inferred shows turtles as a sister group to crocodiles (hypothesis C)."
  },
  {
    "objectID": "phylogeny_inference_ml.html#applying-partition-models",
    "href": "phylogeny_inference_ml.html#applying-partition-models",
    "title": "4  Maximum likelihood-based phylogeny inference",
    "section": "4.4 Applying partition models",
    "text": "4.4 Applying partition models\nNow, we will infer a ML tree applying a partition model (Chernomor, Von Haeseler, and Minh 2016), which means that each partition (specified in the turtle.nex file) will be allowed to have its own model.\n\niqtree2 -s data/turtle.fa -p data/turtle.nex -B 1000 -T 2\n\n\n\n\n\n\n\nUnderstanding the command-line arguments\n\n\n\nThe only new argument here is -p turtle.nex, which is used to specify an edge-linked proportional partition model, so that each partition can have shorter or longer tree length (i.e., slower or faster evolutionary rates, respectively).\n\n\nAs in the simpler IQ-TREE run, the main report is in a file ending in .nex.iqtree, and the tree is in a file named .nex.treefile.\n\n\n\n\n\n\nExercises\n\n\n\n\nLook at the report file in data/turtle.nex.iqtree. What are the AIC/AICc/BIC scores of the partition model? Is it better than the previous model?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Read file\npart_report &lt;- readLines(here(\"data\", \"turtle.nex.iqtree\"))\n\n# Take a look at the best models per partition\npart_report[grepl(\"Best-fit model\", part_report)]\n\n[1] \"Best-fit model according to BIC: K2P+I+G4:ENSGALG00000000223.macse_DNA_gb,K2P+G4:ENSGALG00000001529.macse_DNA_gb,TN+F+G4:ENSGALG00000002002.macse_DNA_gb,TVM+F+I+G4:ENSGALG00000002514.macse_DNA_gb,TIM2e+I+G4:ENSGALG00000003337.macse_DNA_gb,TIM2+F+G4:ENSGALG00000003700.macse_DNA_gb,TN+F+G4:ENSGALG00000003702.macse_DNA_gb,K2P+I+G4:ENSGALG00000003907.macse_DNA_gb,TNe+I:ENSGALG00000005820.macse_DNA_gb,TIM2+F+G4:ENSGALG00000005834.macse_DNA_gb,TNe+G4:ENSGALG00000005902.macse_DNA_gb,TIM3e+G4:ENSGALG00000008338.macse_DNA_gb,TPM2+F+G4:ENSGALG00000008517.macse_DNA_gb,TPM2+F+I+G4:ENSGALG00000008916.macse_DNA_gb,TIM2+F+R3:ENSGALG00000009085.macse_DNA_gb,TN+F+G4:ENSGALG00000009879.macse_DNA_gb,TPM3+F+G4:ENSGALG00000011323.macse_DNA_gb,TIM3e+I+G4:ENSGALG00000011434.macse_DNA_gb,TIM3+F+G4:ENSGALG00000011917.macse_DNA_gb,K2P+G4:ENSGALG00000011966.macse_DNA_gb,SYM+G4:ENSGALG00000012244.macse_DNA_gb,TN+F+G4:ENSGALG00000012379.macse_DNA_gb,TNe+G4:ENSGALG00000012568.macse_DNA_gb,TPM2+F+G4:ENSGALG00000013227.macse_DNA_gb,TN+F+G4:ENSGALG00000014038.macse_DNA_gb,TN+F+G4:ENSGALG00000014648.macse_DNA_gb,TIM+F+G4:ENSGALG00000015326.macse_DNA_gb,TIM2+F+G4:ENSGALG00000015397.macse_DNA_gb,TPM2+F+I+G4:ENSGALG00000016241.macse_DNA_gb\"\n\n# See the AIC/AICc/BIC scores per partition\nidx &lt;- grep(\"List of best-fit models\", part_report)\nidx &lt;- seq(idx, idx + 30)\n\npart_report[idx]\n\n [1] \"List of best-fit models per partition:\"                                                                   \n [2] \"\"                                                                                                         \n [3] \"  ID  Model                  LogL         AIC      w-AIC        AICc     w-AICc         BIC      w-BIC\"   \n [4] \"   1  K2P+I+G4          -5095.247   10198.494 + 1.42e-316   10198.541 + 5.45e-317   10217.456 + 1.24e-316\"\n [5] \"   2  K2P+G4            -3419.486    6844.972 + 1.42e-316    6845.018 + 5.45e-317    6857.745 + 1.24e-316\"\n [6] \"   3  TN+F+G4           -3609.176    7232.351 + 1.42e-316    7232.520 + 5.45e-317    7263.923 + 1.24e-316\"\n [7] \"   4  TVM+F+I+G4        -4289.021    8598.043 + 1.42e-316    8598.348 + 5.45e-317    8644.001 + 1.24e-316\"\n [8] \"   5  TIM2e+I+G4        -6224.713   12461.426 + 1.42e-316   12461.514 + 5.45e-317   12490.665 + 1.24e-316\"\n [9] \"   6  TIM2+F+G4         -4719.062    9454.125 + 1.42e-316    9454.289 + 5.45e-317    9492.409 + 1.24e-316\"\n[10] \"   7  TN+F+G4           -7633.586   15281.172 + 1.42e-316   15281.244 + 5.45e-317   15318.571 + 1.24e-316\"\n[11] \"   8  K2P+I+G4          -2959.348    5926.696 + 1.42e-316    5926.780 + 5.45e-317    5943.391 + 1.24e-316\"\n[12] \"   9  TNe+I             -3109.902    6227.805 + 1.42e-316    6227.875 + 5.45e-317    6245.229 + 1.24e-316\"\n[13] \"  10  TIM2+F+G4         -3040.697    6097.394 + 1.42e-316    6097.604 + 5.45e-317    6133.757 + 1.24e-316\"\n[14] \"  11  TNe+G4            -2864.568    5737.135 + 1.42e-316    5737.206 + 5.45e-317    5754.518 + 1.24e-316\"\n[15] \"  12  TIM3e+G4          -5169.589   10349.179 + 1.42e-316   10349.255 + 5.45e-317   10372.552 + 1.24e-316\"\n[16] \"  13  TPM2+F+G4         -2702.092    5418.183 + 1.42e-316    5418.394 + 5.45e-317    5448.224 + 1.24e-316\"\n[17] \"  14  TPM2+F+I+G4       -3667.885    7351.771 + 1.42e-316    7352.039 + 5.45e-317    7386.192 + 1.24e-316\"\n[18] \"  15  TIM2+F+R3         -4532.069    9086.138 + 1.42e-316    9086.426 + 5.45e-317    9139.325 + 1.24e-316\"\n[19] \"  16  TN+F+G4           -4173.396    8360.792 + 1.42e-316    8360.982 + 5.45e-317    8391.535 + 1.24e-316\"\n[20] \"  17  TPM3+F+G4         -5262.146   10538.293 + 1.42e-316   10538.418 + 5.45e-317   10571.909 + 1.24e-316\"\n[21] \"  18  TIM3e+I+G4        -3036.049    6084.098 + 1.42e-316    6084.289 + 5.45e-317    6108.713 + 1.24e-316\"\n[22] \"  19  TIM3+F+G4         -4092.671    8201.341 + 1.42e-316    8201.490 + 5.45e-317    8240.450 + 1.24e-316\"\n[23] \"  20  K2P+G4            -2968.726    5943.452 + 1.42e-316    5943.504 + 5.45e-317    5955.897 + 1.24e-316\"\n[24] \"  21  SYM+G4            -4372.436    8758.871 + 1.42e-316    8759.022 + 5.45e-317    8791.240 + 1.24e-316\"\n[25] \"  22  TN+F+G4           -2870.272    5754.543 + 1.42e-316    5754.763 + 5.45e-317    5784.307 + 1.24e-316\"\n[26] \"  23  TNe+G4            -2919.575    5847.149 + 1.42e-316    5847.213 + 5.45e-317    5864.932 + 1.24e-316\"\n[27] \"  24  TPM2+F+G4         -5568.175   11150.350 + 1.42e-316   11150.437 + 5.45e-317   11186.552 + 1.24e-316\"\n[28] \"  25  TN+F+G4           -3315.859    6645.717 + 1.42e-316    6645.920 + 5.45e-317    6676.025 + 1.24e-316\"\n[29] \"  26  TN+F+G4           -2097.847    4209.693 + 1.42e-316    4209.922 + 5.45e-317    4239.168 + 1.24e-316\"\n[30] \"  27  TIM+F+G4          -3743.957    7503.913 + 1.42e-316    7504.158 + 5.45e-317    7539.049 + 1.24e-316\"\n[31] \"  28  TIM2+F+G4         -3634.194    7284.388 + 1.42e-316    7284.634 + 5.45e-317    7319.483 + 1.24e-316\"\n\n\nScores are better (lower BIC scores, for instance).\n\n\n\n\nVisualize the tree in data/turtle.nex.treefile. What relationship among three trees does this tree support? What is the ultrafast bootstrap support (%) for the relevant clade?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ntree &lt;- read.tree(here(\"data\", \"turtle.nex.treefile\"))\n\nplot(tree, show.node.label = TRUE)\n\n\n\n\nThe tree supports the “A” hypothesis, which positions turtles as a sister group to birds and crocodiles. The branch showing that turtles are a sister group to crocodiles has a bootstrap support of 100%.\n\n\n\n\nDoes the inferred tree agree with the published tree (Chiari et al. 2012)?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nYes. Both trees agree on the “A” hypothesis."
  },
  {
    "objectID": "phylogeny_inference_ml.html#selecting-the-best-partitioning-scheme-with-partitionfinder",
    "href": "phylogeny_inference_ml.html#selecting-the-best-partitioning-scheme-with-partitionfinder",
    "title": "4  Maximum likelihood-based phylogeny inference",
    "section": "4.5 Selecting the best partitioning scheme with PartitionFinder",
    "text": "4.5 Selecting the best partitioning scheme with PartitionFinder\nNow, we will use PartitionFinder (Lanfear et al. 2012) to merge partitions and reduce the potential over-parameterization.\n\niqtree2 -s data/turtle.fa -p data/turtle.nex -B 1000 -T 2 -m MFP+MERGE -rcluster 10 --prefix data/turtle.merge\n\n\n\n\n\n\n\nUnderstanding the command-line arguments\n\n\n\nBesides the arguments we’ve already seen, the new arguments and their meanings are:\n\n-m: specifies the model to use. Here, MFP+MERGE indicates running PartitionFinder followed by tree reconstruction.\n-rcluster: to reduce computations by only examining the top n% (here, 10%) partitioning schemes using the relaxed clustering algorithm (Lanfear et al. 2014).\n--prefix: specifies the prefix for all output files to avoid overwriting the output of previous runs.\n\n\n\nThe main report is a file ending in .merge.iqtree, and the tree is in a file ending in .merge.treefile.\n\n\n\n\n\n\nExercises\n\n\n\n\nLook at the report file data/turtle.merge.iqtree and answer the questions:\n\nHow many partitions do we have now?\nLook at the AIC/AICc/BIC scores. Compared with two previous models, is this model better or worse?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Read report\nmerge_report &lt;- readLines(here(\"data\", \"turtle.merge.iqtree\"))\n\n# Q1: number of partitions\nmerge_report[grepl(\"Input data:\", merge_report)]\n\n[1] \"Input data: 16 taxa with 7 partitions and 20820 total sites (2.55764% missing data)\"\n\n# Q2: compare AIC/AICc/BIC scores\nidx &lt;- grep(\"List of best-fit models per partition\", merge_report)\nidx &lt;- seq(idx, idx + 10)\n\nmerge_report[idx]\n\n [1] \"List of best-fit models per partition:\"                                                                   \n [2] \"\"                                                                                                         \n [3] \"  ID  Model                  LogL         AIC      w-AIC        AICc     w-AICc         BIC      w-BIC\"   \n [4] \"   1  TPM3+F+I+G4      -33463.275   66942.550 + 3.38e-316   66942.577 + 5.45e-317   66995.241 + 2.19e-316\"\n [5] \"   2  TIM3+F+I+G4      -28588.305   57194.610 + 3.38e-316   57194.643 + 5.45e-317   57254.076 + 2.19e-316\"\n [6] \"   3  GTR+F+I+G4       -19434.040   38890.081 + 3.38e-316   38890.158 + 5.45e-317   38957.582 + 2.19e-316\"\n [7] \"   4  TIM2e+I+G4        -6224.893   12461.787 + 3.38e-316   12461.874 + 5.45e-317   12491.026 + 2.19e-316\"\n [8] \"   5  TIM2+F+G4        -17553.560   35123.120 + 3.38e-316   35123.156 + 5.45e-317   35173.507 + 2.19e-316\"\n [9] \"   6  TVMe+I+G4         -6727.848   13469.695 + 3.38e-316   13469.809 + 5.45e-317   13504.000 + 2.19e-316\"\n[10] \"   7  TIM+F+G4          -3743.955    7503.910 + 3.38e-316    7504.155 + 5.45e-317    7539.045 + 2.19e-316\"\n[11] \"\"                                                                                                         \n\n\n\n\n\n\nVisualize the tree in data/turtle.merge.treefile. What relationship among three trees does this tree support? What is the ultrafast bootstrap support (%) for the relevant clade?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ntree &lt;- read.tree(here(\"data\", \"turtle.merge.treefile\"))\n\nplot(tree, show.node.label = TRUE)\n\n\n\n\nThe tree supports the hypothesis A, which positions turtles as a sister group to birds and crocodiles. The relevant clade has a bootstrap support of 99%.\n\n\n\n\nDoes this tree agree with the published tree (Chiari et al. 2012)?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nYes. Both trees agree on the “A” hypothesis, i.e., (Turtle, (Bird, Crocodile))."
  },
  {
    "objectID": "phylogeny_inference_ml.html#tree-topology-tests",
    "href": "phylogeny_inference_ml.html#tree-topology-tests",
    "title": "4  Maximum likelihood-based phylogeny inference",
    "section": "4.6 Tree topology tests",
    "text": "4.6 Tree topology tests\nTree topology tests can be used to find out if different trees have significant differences in log-likelihoods. To do that, you can use the SH test (Shimodaira and Hasegawa 1999) or expected likelihood weights (Strimmer and Rambaut 2002).\nBefore running the tests, we first need to concatenate the trees in a single file:\n\n# Read tree inferred with a single model as plain text\ntree_single &lt;- readLines(here(\"data\", \"turtle.fa.treefile\"))\n\n# Read tree inferred with partition models as plain text\ntree_partitioned &lt;- readLines(here(\"data\", \"turtle.nex.treefile\"))\n\n# Combine trees and export to file\ntree_combined &lt;- c(tree_single, tree_partitioned)\nwriteLines(tree_combined, con = here(\"data\", \"turtle.trees\"))\n\nNow, we can pass the concatenated tree to IQ-TREE:\n\niqtree2 -s data/turtle.fa -p data/turtle.merge.best_scheme.nex -z data/turtle.trees -zb 10000 -au -n 0 --prefix data/turtle.test\n\n\n\n\n\n\n\nUnderstanding the command-line arguments\n\n\n\nBesides the arguments we’ve already seen, the new arguments and their meanings are:\n\n-z: path to the file containing the concatenated trees.\n-zb: number of replicates for approximate bootstrap for the tree topology tests (here, 10000).\n-au: perform the Approximately Unbiased test.\n-n 0: avoid tree search and just perform tree topology tests.\n\n\n\nThe main report is a file ending in .test.iqtree, and the tree is in a file ending in .test.treefile.\nThe KH, SH and AU tests return p-values. Thus, a tree is rejected if its p-value &lt;0.05 (marked with a - sign).\n\n\n\n\n\n\nExercises\n\n\n\n\nLook at the “USER TREES” section in the report file data/turtle.test.iqtree and answer the questions:\n\nWhich tree has the worst log-likelihood?\nCan you reject this tree according to the Shimodaira Hasegawa test, assuming a p-value cutoff of 0.05?\nCan you reject this tree according to the Approximately Unbiased test, assuming a p-value cutoff of 0.05?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Read report and get the \"USER TREES\" section\ntest_report &lt;- readLines(here(\"data\", \"turtle.test.iqtree\"))\nidx &lt;- grep(\"USER TREES\", test_report)\nidx &lt;- seq(idx, length(test_report))\n\ntest_report[idx]\n\n [1] \"USER TREES\"                                                                  \n [2] \"----------\"                                                                  \n [3] \"\"                                                                            \n [4] \"See data/turtle.test.trees for trees with branch lengths.\"                   \n [5] \"\"                                                                            \n [6] \"Tree      logL    deltaL  bp-RELL    p-KH     p-SH       c-ELW       p-AU\"   \n [7] \"-------------------------------------------------------------------------\"   \n [8] \"  1 -115741.0735  4.9507   0.424 +  0.426 +  0.426 +     0.424 +    0.412 + \"\n [9] \"  2 -115736.1228       0   0.576 +  0.574 +      1 +     0.576 +    0.588 + \"\n[10] \"\"                                                                            \n[11] \"deltaL  : logL difference from the maximal logl in the set.\"                 \n[12] \"bp-RELL : bootstrap proportion using RELL method (Kishino et al. 1990).\"     \n[13] \"p-KH    : p-value of one sided Kishino-Hasegawa test (1989).\"                \n[14] \"p-SH    : p-value of Shimodaira-Hasegawa test (2000).\"                       \n[15] \"c-ELW   : Expected Likelihood Weight (Strimmer & Rambaut 2002).\"             \n[16] \"p-AU    : p-value of approximately unbiased (AU) test (Shimodaira, 2002).\"   \n[17] \"\"                                                                            \n[18] \"Plus signs denote the 95% confidence sets.\"                                  \n[19] \"Minus signs denote significant exclusion.\"                                   \n[20] \"All tests performed 10000 resamplings using the RELL method.\"                \n[21] \"\"                                                                            \n[22] \"TIME STAMP\"                                                                  \n[23] \"----------\"                                                                  \n[24] \"\"                                                                            \n[25] \"Date and time: Wed Apr 12 10:10:34 2023\"                                     \n[26] \"Total CPU time used: 6.99 seconds (0h:0m:6s)\"                                \n[27] \"Total wall-clock time used: 17 seconds (0h:0m:17s)\"                          \n[28] \"\"                                                                            \n\n\n\nThe first tree has the worst log-likelihood.\nNo, we cannot reject the tree (p = 0.426).\nNo, we cannot reject the tree (p = 0.412)."
  },
  {
    "objectID": "phylogeny_inference_ml.html#references",
    "href": "phylogeny_inference_ml.html#references",
    "title": "4  Maximum likelihood-based phylogeny inference",
    "section": "References",
    "text": "References\n\n\n\n\nChernomor, Olga, Arndt Von Haeseler, and Bui Quang Minh. 2016. “Terrace Aware Data Structure for Phylogenomic Inference from Supermatrices.” Systematic Biology 65 (6): 997–1008.\n\n\nChiari, Ylenia, Vincent Cahais, Nicolas Galtier, and Frédéric Delsuc. 2012. “Phylogenomic Analyses Support the Position of Turtles as the Sister Group of Birds and Crocodiles (Archosauria).” Bmc Biology 10: 1–15.\n\n\nLanfear, Robert, Brett Calcott, Simon YW Ho, and Stephane Guindon. 2012. “PartitionFinder: Combined Selection of Partitioning Schemes and Substitution Models for Phylogenetic Analyses.” Molecular Biology and Evolution 29 (6): 1695–1701.\n\n\nLanfear, Robert, Brett Calcott, David Kainer, Christoph Mayer, and Alexandros Stamatakis. 2014. “Selecting Optimal Partitioning Schemes for Phylogenomic Datasets.” BMC Evolutionary Biology 14: 1–14.\n\n\nMinh, Bui Quang, Minh Anh Thi Nguyen, and Arndt Von Haeseler. 2013. “Ultrafast Approximation for Phylogenetic Bootstrap.” Molecular Biology and Evolution 30 (5): 1188–95.\n\n\nMinh, Bui Quang, Heiko A Schmidt, Olga Chernomor, Dominik Schrempf, Michael D Woodhams, Arndt Von Haeseler, and Robert Lanfear. 2020. “IQ-TREE 2: New Models and Efficient Methods for Phylogenetic Inference in the Genomic Era.” Molecular Biology and Evolution 37 (5): 1530–34.\n\n\nShimodaira, Hidetoshi, and Masami Hasegawa. 1999. “Multiple Comparisons of Log-Likelihoods with Applications to Phylogenetic Inference.” Molecular Biology and Evolution 16 (8): 1114.\n\n\nStrimmer, Korbinian, and Andrew Rambaut. 2002. “Inferring Confidence Sets of Possibly Misspecified Gene Trees.” Proceedings of the Royal Society of London. Series B: Biological Sciences 269 (1487): 137–42."
  },
  {
    "objectID": "gene_genome_duplication.html#goals-of-this-lesson",
    "href": "gene_genome_duplication.html#goals-of-this-lesson",
    "title": "5  Analysis of gene and genome duplication",
    "section": "5.1 Goals of this lesson",
    "text": "5.1 Goals of this lesson\nIn this lesson, you will learn to:\n\nIdentify duplicated gene pairs from whole-genome protein sequences.\nClassify duplicated genes based on their mode of duplication.\nCalculate substitution rates (\\(K_a\\) and \\(K_s\\)) per substitution site.\nIdentify whole-genome duplication events in Ks distributions."
  },
  {
    "objectID": "gene_genome_duplication.html#identifying-duplicated-gene-pairs",
    "href": "gene_genome_duplication.html#identifying-duplicated-gene-pairs",
    "title": "5  Analysis of gene and genome duplication",
    "section": "5.2 Identifying duplicated gene pairs",
    "text": "5.2 Identifying duplicated gene pairs\nHere, we will use the example data sets that come with the {doubletrouble} package, which contain sequences and annotation for the yeast species Saccharomyces cerevisiae and Candida glabrata. The example data are:\n\nyeast_seq: A list of AAStringSet objects (length 2, Scerevisiae and Cglabrata) containing whole-genome protein sequences.\nyeast_annot: A GRangesList object (length 2, Scerevisiae and Cglabrata) containing gene annotation (i.e., gene ranges).\ndiamond_intra: A list of data frames (length 1, Scerevisiae_Scerevisiae) with the output of DIAMOND similarity searches between S. cerevisiae against itself.\ndiamond_inter: A list of data frames (length 1, Scerevisiae_Cglabrata) with the output of DIAMOND similarity searches between S. cerevisiae and C. glabrata.\n\n\nlibrary(doubletrouble)\n\n# Load data\ndata(yeast_seq)\ndata(yeast_annot)\ndata(diamond_intra)\ndata(diamond_inter)\n\n# Take a look at the data\nhead(yeast_seq)\n\n$Scerevisiae\nAAStringSet object of length 6600:\n       width seq                                            names               \n   [1]  4910 MSQDRILLDLDVVNQRLILFNS...SELPEMLSLILRQYFTDLASS YLR106C\n   [2]  4092 MCKNEARLANELIEFVAATVTG...NYERLQAKEVASSTEQLLQEM YKR054C\n   [3]  3744 MSLTEQIEQFASRFRDDDATLQ...IGSAVSPRNLARTDVNFMPWF YHR099W\n   [4]  3268 MVLFTRCEKARKEKLAAGYKPL...ETLRGSLLLAINEGHEGFGLA YDR457W\n   [5]  3144 MLESLAANLLNRLLGSYVENFD...SLYRNIAIAVREYNKYCEAIL YLL040C\n   ...   ... ...\n[6596]    25 MFSLSNSQYTCQDYISDHIWKTSSH                      YOR302W\n[6597]    25 MRAKWRKKRTRRLKRKRRKVRARSK                      YDL133C-A\n[6598]    24 MHSNNSRQILIPHQNENMFLTELY                       YDL247W-A\n[6599]    24 MLVLYRKRFSGFRFYFLSIFKYII                       YBR191W-A\n[6600]    16 MLSLIFYLRFPSYIRG                               YJR151W-A\n\n$Cglabrata\nAAStringSet object of length 5293:\n       width seq                                            names               \n   [1]  4880 MSIQSADTVVFDLDKAFQRRDE...VELPEMLALILRQYFSDLASQ CAGL0M11616g\n   [2]  4336 MYCIIRLCLLLLYMVRFAAAIV...ITFLGIKKCIILLIIVVVSIA CAGL0I10147g\n   [3]  4041 MVQRNIELARYITTLLIGVCPK...NDIESKVLDDTKQLLNSIEYV CAGL0K08294g\n   [4]  3743 MASADQISEYAEKLKDDQQSLA...ISASVNPRNLAKTDISFMPWF CAGL0A01914g\n   [5]  3247 MVKLTRFEKLQKEKNAEYFKPF...DTLRGSLLIAINEGHEGFGLA CAGL0K06303g\n   ...   ... ...\n[5289]    43 MLGAPISRDTPRKTRSKTQFFQGPIVSLITEKCTYEWGNPSIN    CAGL0M02541g\n[5290]    39 MLPGGPIVVLILVGLAACIIVATIIYRKWQERQRALARF        CAGL0M03305g\n[5291]    39 MLPGGVILVFILVGLAACAIVAVIIYRKWQERQRSLQRF        CAGL0L08008g\n[5292]    37 MINEGQLQTLVIGFGLAMVVLVVVYHAVASTMAVKRD          CAGL0C05461g\n[5293]    34 MQPTIEATQKDNTQEKRDNYIVKGFFWSPDCVIA             CAGL0C01919g\n\nhead(yeast_annot)\n\nGRangesList object of length 2:\n$Scerevisiae\nGRanges object with 6600 ranges and 2 metadata columns:\n         seqnames        ranges strand |     type     gene_id\n            &lt;Rle&gt;     &lt;IRanges&gt;  &lt;Rle&gt; | &lt;factor&gt; &lt;character&gt;\n     [1]        I       335-649      + |     gene     YAL069W\n     [2]        I       538-792      + |     gene   YAL068W-A\n     [3]        I     1807-2169      - |     gene     YAL068C\n     [4]        I     2480-2707      + |     gene   YAL067W-A\n     [5]        I     7235-9016      - |     gene     YAL067C\n     ...      ...           ...    ... .      ...         ...\n  [6596]      XVI 939922-941136      + |     gene     YPR201W\n  [6597]      XVI 943032-943896      + |     gene     YPR202W\n  [6598]      XVI 943880-944188      + |     gene     YPR203W\n  [6599]      XVI 944603-947701      + |     gene     YPR204W\n  [6600]      XVI 946856-947338      - |     gene   YPR204C-A\n  -------\n  seqinfo: 31 sequences from an unspecified genome; no seqlengths\n\n$Cglabrata\nGRanges object with 5293 ranges and 2 metadata columns:\n                       seqnames      ranges strand |     type      gene_id\n                          &lt;Rle&gt;   &lt;IRanges&gt;  &lt;Rle&gt; | &lt;factor&gt;  &lt;character&gt;\n     [1] ChrA_C_glabrata_CBS138   1608-2636      - |     gene CAGL0A00105g\n     [2] ChrA_C_glabrata_CBS138   2671-4809      - |     gene CAGL0A00116g\n     [3] ChrA_C_glabrata_CBS138 11697-13042      + |     gene CAGL0A00132g\n     [4] ChrA_C_glabrata_CBS138 14977-15886      + |     gene CAGL0A00154g\n     [5] ChrA_C_glabrata_CBS138 17913-19017      - |     gene CAGL0A00165g\n     ...                    ...         ...    ... .      ...          ...\n  [5289] mito_C_glabrata_CBS138 13275-13421      + |     gene    CaglfMp08\n  [5290] mito_C_glabrata_CBS138 13614-14396      + |     gene    CaglfMp09\n  [5291] mito_C_glabrata_CBS138 14631-14861      + |     gene    CaglfMp10\n  [5292] mito_C_glabrata_CBS138 15384-16067      + |     gene    CaglfMp11\n  [5293] mito_C_glabrata_CBS138 16756-17565      + |     gene    CaglfMp12\n  -------\n  seqinfo: 31 sequences from an unspecified genome; no seqlengths\n\nhead(diamond_intra$Scerevisiae_Scerevisiae)\n\n        query          db perc_identity length mismatches gap_open qstart qend\n1 Sce_YLR106C Sce_YLR106C         100.0   4910          0        0      1 4910\n2 Sce_YLR106C Sce_YKR054C          22.4    420        254       19    804 1195\n3 Sce_YKR054C Sce_YKR054C         100.0   4092          0        0      1 4092\n4 Sce_YKR054C Sce_YLR106C          22.4    420        254       19   1823 2198\n5 Sce_YHR099W Sce_YHR099W         100.0   3744          0        0      1 3744\n6 Sce_YHR099W Sce_YJR066W          22.7    339        201       12   3351 3674\n  tstart tend   evalue bitscore\n1      1 4910 0.00e+00   9095.0\n2   1823 2198 1.30e-06     53.1\n3      1 4092 0.00e+00   7940.0\n4    804 1195 1.09e-06     53.1\n5      1 3744 0.00e+00   7334.0\n6   2074 2366 6.46e-08     57.0\n\nhead(diamond_inter$Scerevisiae_Cglabrata)\n\n        query               db perc_identity length mismatches gap_open qstart\n1 Sce_YLR106C Cgl_CAGL0M11616g          52.3   4989       2183       50      2\n2 Sce_YLR106C Cgl_CAGL0K08294g          23.1    347        215       12   1064\n3 Sce_YKR054C Cgl_CAGL0K08294g          26.5   4114       2753       81     83\n4 Sce_YKR054C Cgl_CAGL0M11616g          22.7    419        254       17   1823\n5 Sce_YHR099W Cgl_CAGL0A01914g          70.2   3761       1087       17      1\n6 Sce_YDR457W Cgl_CAGL0K06303g          55.5   3318       1355       39      1\n  qend tstart tend   evalue bitscore\n1 4909      5 4879 0.00e+00   4439.0\n2 1389   1770 2085 9.10e-07     53.5\n3 4089     87 4035 0.00e+00   1376.0\n4 2198    803 1194 7.59e-07     53.5\n5 3744      1 3743 0.00e+00   5200.0\n6 3268      1 3247 0.00e+00   3302.0\n\n\n\n\n\n\n\n\nExercises\n\n\n\nExplore the example data sets to answer the following questions:\n\nIs the number of sequences in yeast_seq the same as the number of gene ranges in yeast_annot for S. cerevisiae?\nHow many genes are there in S. cerevisiae’s chromosome 1?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Q1\nlength(yeast_seq$Scerevisiae)\n\n[1] 6600\n\nlength(yeast_annot$Scerevisiae)\n\n[1] 6600\n\n# Q2\ntable(GenomicRanges::seqnames(yeast_annot$Scerevisiae))\n\n\n   I   II  III   IV    V   VI  VII VIII   IX    X   XI  XII XIII  XIV   XV  XVI \n 117  456  184  836  323  139  583  321  241  398  348  578  505  435  597  511 \nMito \n  28"
  },
  {
    "objectID": "gene_genome_duplication.html#classifying-duplicate-pairs",
    "href": "gene_genome_duplication.html#classifying-duplicate-pairs",
    "title": "5  Analysis of gene and genome duplication",
    "section": "5.3 Classifying duplicate pairs",
    "text": "5.3 Classifying duplicate pairs\n{doubletrouble} classifies duplicated gene pairs into the following modes: whole-genome duplication (WGD), tandem duplication (TD), proximal duplication (PD), transposed duplication (TRD, optional), and dispersed duplication (DD).\nTo find WGD-derived genes, {doubletrouble} relies on synteny information identified with {syntenet} (Almeida-Silva et al. 2023). Thus, we first need to process the input sequences and annotation to a format that {syntenet} understands. We do that with the process_input() function.\n\nlibrary(syntenet)\n\n# Process input data\npdata &lt;- process_input(yeast_seq, yeast_annot)\n\n# Inspect the output\nnames(pdata)\n\n[1] \"seq\"        \"annotation\"\n\npdata$seq\n\n$Scerevisiae\nAAStringSet object of length 6600:\n       width seq                                            names               \n   [1]  4910 MSQDRILLDLDVVNQRLILFNS...SELPEMLSLILRQYFTDLASS Sce_YLR106C\n   [2]  4092 MCKNEARLANELIEFVAATVTG...NYERLQAKEVASSTEQLLQEM Sce_YKR054C\n   [3]  3744 MSLTEQIEQFASRFRDDDATLQ...IGSAVSPRNLARTDVNFMPWF Sce_YHR099W\n   [4]  3268 MVLFTRCEKARKEKLAAGYKPL...ETLRGSLLLAINEGHEGFGLA Sce_YDR457W\n   [5]  3144 MLESLAANLLNRLLGSYVENFD...SLYRNIAIAVREYNKYCEAIL Sce_YLL040C\n   ...   ... ...\n[6596]    25 MFSLSNSQYTCQDYISDHIWKTSSH                      Sce_YOR302W\n[6597]    25 MRAKWRKKRTRRLKRKRRKVRARSK                      Sce_YDL133C-A\n[6598]    24 MHSNNSRQILIPHQNENMFLTELY                       Sce_YDL247W-A\n[6599]    24 MLVLYRKRFSGFRFYFLSIFKYII                       Sce_YBR191W-A\n[6600]    16 MLSLIFYLRFPSYIRG                               Sce_YJR151W-A\n\n$Cglabrata\nAAStringSet object of length 5293:\n       width seq                                            names               \n   [1]  4880 MSIQSADTVVFDLDKAFQRRDE...VELPEMLALILRQYFSDLASQ Cgl_CAGL0M11616g\n   [2]  4336 MYCIIRLCLLLLYMVRFAAAIV...ITFLGIKKCIILLIIVVVSIA Cgl_CAGL0I10147g\n   [3]  4041 MVQRNIELARYITTLLIGVCPK...NDIESKVLDDTKQLLNSIEYV Cgl_CAGL0K08294g\n   [4]  3743 MASADQISEYAEKLKDDQQSLA...ISASVNPRNLAKTDISFMPWF Cgl_CAGL0A01914g\n   [5]  3247 MVKLTRFEKLQKEKNAEYFKPF...DTLRGSLLIAINEGHEGFGLA Cgl_CAGL0K06303g\n   ...   ... ...\n[5289]    43 MLGAPISRDTPRKTRSKTQFFQGPIVSLITEKCTYEWGNPSIN    Cgl_CAGL0M02541g\n[5290]    39 MLPGGPIVVLILVGLAACIIVATIIYRKWQERQRALARF        Cgl_CAGL0M03305g\n[5291]    39 MLPGGVILVFILVGLAACAIVAVIIYRKWQERQRSLQRF        Cgl_CAGL0L08008g\n[5292]    37 MINEGQLQTLVIGFGLAMVVLVVVYHAVASTMAVKRD          Cgl_CAGL0C05461g\n[5293]    34 MQPTIEATQKDNTQEKRDNYIVKGFFWSPDCVIA             Cgl_CAGL0C01919g\n\npdata$annotation\n\n$Scerevisiae\nGRanges object with 6600 ranges and 1 metadata column:\n         seqnames        ranges strand |          gene\n            &lt;Rle&gt;     &lt;IRanges&gt;  &lt;Rle&gt; |   &lt;character&gt;\n     [1]    Sce_I       335-649      * |   Sce_YAL069W\n     [2]    Sce_I       538-792      * | Sce_YAL068W-A\n     [3]    Sce_I     1807-2169      * |   Sce_YAL068C\n     [4]    Sce_I     2480-2707      * | Sce_YAL067W-A\n     [5]    Sce_I     7235-9016      * |   Sce_YAL067C\n     ...      ...           ...    ... .           ...\n  [6596]  Sce_XVI 939922-941136      * |   Sce_YPR201W\n  [6597]  Sce_XVI 943032-943896      * |   Sce_YPR202W\n  [6598]  Sce_XVI 943880-944188      * |   Sce_YPR203W\n  [6599]  Sce_XVI 944603-947701      * |   Sce_YPR204W\n  [6600]  Sce_XVI 946856-947338      * | Sce_YPR204C-A\n  -------\n  seqinfo: 17 sequences from an unspecified genome; no seqlengths\n\n$Cglabrata\nGRanges object with 5293 ranges and 1 metadata column:\n                       seqnames      ranges strand |             gene\n                          &lt;Rle&gt;   &lt;IRanges&gt;  &lt;Rle&gt; |      &lt;character&gt;\n     [1] Cgl_ChrA_C_glabrata_..   1608-2636      * | Cgl_CAGL0A00105g\n     [2] Cgl_ChrA_C_glabrata_..   2671-4809      * | Cgl_CAGL0A00116g\n     [3] Cgl_ChrA_C_glabrata_.. 11697-13042      * | Cgl_CAGL0A00132g\n     [4] Cgl_ChrA_C_glabrata_.. 14977-15886      * | Cgl_CAGL0A00154g\n     [5] Cgl_ChrA_C_glabrata_.. 17913-19017      * | Cgl_CAGL0A00165g\n     ...                    ...         ...    ... .              ...\n  [5289] Cgl_mito_C_glabrata_.. 13275-13421      * |    Cgl_CaglfMp08\n  [5290] Cgl_mito_C_glabrata_.. 13614-14396      * |    Cgl_CaglfMp09\n  [5291] Cgl_mito_C_glabrata_.. 14631-14861      * |    Cgl_CaglfMp10\n  [5292] Cgl_mito_C_glabrata_.. 15384-16067      * |    Cgl_CaglfMp11\n  [5293] Cgl_mito_C_glabrata_.. 16756-17565      * |    Cgl_CaglfMp12\n  -------\n  seqinfo: 14 sequences from an unspecified genome; no seqlengths\n\n\nThe processed data can be used as input to run_diamond(), which performs similarity searches with DIAMOND to identify intra and interspecies homologous genes. Here, as we already have pre-computed DIAMOND results in diamond_intra and diamond_inter, we will not execute run_diamond(), but you can see its usage in the {doubletrouble}’s vignette.\nNow, let’s classify the duplicated gene pairs of S. cerevisiae.\n\n# Classify duplicated genes using the full scheme\nc_full &lt;- classify_gene_pairs(\n    blast_list = diamond_intra,\n    annotation = pdata$annotation,\n    binary = FALSE,\n    blast_inter = diamond_inter\n)\n\n# Inspecting the output\nnames(c_full)\n\n[1] \"Scerevisiae\"\n\nhead(c_full$Scerevisiae)\n\n         dup1        dup2 type\n1 Sce_YGR032W Sce_YLR342W  WGD\n2 Sce_YOR396W Sce_YPL283C  WGD\n3 Sce_YJL225C Sce_YIL177C  WGD\n4 Sce_YNR031C Sce_YCR073C  WGD\n5 Sce_YOR326W Sce_YAL029C  WGD\n6 Sce_YJL222W Sce_YIL173W  WGD\n\n\n\n\n\n\n\n\nExercises\n\n\n\nHow many gene pairs are there per mode? Hint: you can use the table() function.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ntable(c_full$Scerevisiae$type)\n\n\n  DD   PD   TD  TRD  WGD \n3121   80   42    3  342"
  },
  {
    "objectID": "gene_genome_duplication.html#assigning-genes-into-unique-modes-of-duplication",
    "href": "gene_genome_duplication.html#assigning-genes-into-unique-modes-of-duplication",
    "title": "5  Analysis of gene and genome duplication",
    "section": "5.4 Assigning genes into unique modes of duplication",
    "text": "5.4 Assigning genes into unique modes of duplication\nBecause a gene can be duplicated multiple times by different mechanisms, the same gene can appear in multiple duplicated gene pairs. However, {doubletrouble} lets you classify genes into unique modes of duplication using the following hierarchy: WGD &gt; TD &gt; PD &gt; TRD &gt; DD. Let’s do that with the function classify_genes().\n\n# Classify genes into unique modes of duplication\nc_genes &lt;- classify_genes(c_full)\n\n# Inspecting the output\nnames(c_genes)\n\n[1] \"Scerevisiae\"\n\nhead(c_genes$Scerevisiae)\n\n            gene type\n2360 Sce_YGR032W  WGD\n2361 Sce_YOR396W  WGD\n2362 Sce_YJL225C  WGD\n2363 Sce_YNR031C  WGD\n2364 Sce_YOR326W  WGD\n2365 Sce_YJL222W  WGD\n\n\n\n\n\n\n\n\nExercises\n\n\n\nUse the data frame with classified genes to answer the questions below.\n\nHow many duplicated genes are there for each mode?\nWhat is the duplication mode of the gene “YOR326W”?\nWhat is the proportion (in %) of duplicated genes in the S. cerevisiae genome?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Q1\ntable(c_genes$Scerevisiae$type)\n\n\n  DD   PD   TD  TRD  WGD \n1784   70   67    6  683 \n\n# Q2\nc_genes$Scerevisiae[grep(\"YOR326W\", c_genes$Scerevisiae$gene), ]\n\n            gene type\n2364 Sce_YOR326W  WGD\n\n# Q3\n(length(c_genes$Scerevisiae$gene) / length(pdata$seq$Scerevisiae)) * 100\n\n[1] 39.54545"
  },
  {
    "objectID": "gene_genome_duplication.html#calculating-substitution-rates",
    "href": "gene_genome_duplication.html#calculating-substitution-rates",
    "title": "5  Analysis of gene and genome duplication",
    "section": "5.5 Calculating substitution rates",
    "text": "5.5 Calculating substitution rates\nNow, you can use the function pairs2kaks() to calculate rates of nonsynonymous substitutions per nonsynonymous site (\\(K_a\\)), synonymouys substitutions per synonymous site (\\(K_s\\)), and their ratios (\\(\\frac{K_a}{K_s}\\)). Rates are calculated using the codon models in KaKs_Calculator 2.0 (Wang et al. 2010), which are implemented in the Bioconductor package {MSA2dist}.\nFor that, we will need the CDS (DNA sequences) for all S. cerevisiae genes, which are stored in {doubletrouble}’s example data set cds_scerevisiae.\n\n# Load data\ndata(cds_scerevisiae)\nhead(cds_scerevisiae)\n\nDNAStringSet object of length 6:\n    width seq                                               names               \n[1]  5688 ATGTCCTACAACGATCCAAACTT...AGACCTGGTCTACGATCAAATGA YGR032W\n[2]  5631 ATGAACACTGATCAACAACCTTA...AGACCTGGTCAACTATAAAATAA YLR342W\n[3]  5580 ATGGAAATTGAAAACGAACAGAT...CGAGCAGAGAAGTTGGAGAGTGA YPL283C\n[4]  5391 ATGAAAGTTTCCGATAGGCGTAA...CGAGCAGAGAAGTTGGAGAGTGA YOR396W\n[5]  5277 ATGAAAGTTTCCGATAGGCGTAA...CGAGCAGAGAAGTTGGAGAGTGA YJL225C\n[6]  5277 ATGAAAGTTTCCGATAGGCGTAA...CGAGCAGAGAAGTTGGAGAGTGA YIL177C\n\n# Store CDS in a list\ncds_list &lt;- list(Scerevisiae = cds_scerevisiae)\n\n# Calculate Ka, Ks, and Ka/Ks for the first 5 gene pairs for demonstration only\nselected_pairs &lt;- list(Scerevisiae = c_full$Scerevisiae[1:5, ])\nkaks &lt;- pairs2kaks(selected_pairs, cds_list)\n\n# Inspect the output\nkaks\n\n$Scerevisiae\n     dup1    dup2          Ka         Ks     Ka_Ks type\n1 YGR032W YLR342W 0.058810200 5.23576000 0.0112324  WGD\n2 YOR396W YPL283C 0.004007600 0.00991618 0.4041470  WGD\n3 YJL225C YIL177C 0.000253203 0.00075777 0.3341420  WGD\n4 YNR031C YCR073C 0.364041000 5.07223000 0.0717714  WGD\n5 YOR326W YAL029C 0.395973000 5.15058000 0.0768793  WGD\n\n\nPeaks in \\(K_s\\) distributions indicate WGD events. However, because of saturation at high \\(K_s\\) values, only recent WGD events can be reliably identified from \\(K_s\\) distributions. Here, to demonstrate how to identify such peaks, we will use pre-computed \\(K_s\\) values for all soybean paralogous pairs, which is also part of the example data in {doubletrouble}.\n\n# Load data\ndata(gmax_ks)\nhead(gmax_ks)\n\n              dup1            dup2        Ks\n1  GLYMA_01G000100 GLYMA_15G276800 0.3749860\n3  GLYMA_01G000400 GLYMA_02G312300 0.0452761\n8  GLYMA_01G000600 GLYMA_14G000400 0.1040900\n10 GLYMA_01G000800 GLYMA_03G188200 0.4732800\n11 GLYMA_01G000800 GLYMA_05G115300 1.2292300\n12 GLYMA_01G000800 GLYMA_17G191100 1.6607100\n\n# Find peaks\npeaks &lt;- find_ks_peaks(gmax_ks$Ks, npeaks = c(2, 3), verbose = TRUE)\n\nOptimal number of peaks: 3\n\n\nBayesian Information Criterion (BIC): \n          E         V\n2 -86950.21 -67759.55\n3 -86977.96 -54203.15\n\nTop 3 models based on the BIC criterion: \n      V,3       V,2       E,2 \n-54203.15 -67759.55 -86950.21 \n\n# Inspect output\nnames(peaks)\n\n[1] \"mean\"   \"sd\"     \"lambda\" \"ks\"    \n\nstr(peaks)\n\nList of 4\n $ mean  : Named num [1:3] 0.118 0.531 1.481\n  ..- attr(*, \"names\")= chr [1:3] \"1\" \"2\" \"3\"\n $ sd    : num [1:3] 0.0549 0.2442 0.3136\n $ lambda: num [1:3] 0.352 0.433 0.215\n $ ks    : num [1:71231] 0.375 0.0453 0.1041 0.4733 1.2292 ...\n\n# Visualize peaks\nplot_ks_peaks(peaks)\n\n\n\n\nFinally, since GMMs can lead to overfitting and overclustering in some cases, let’s assess the significance of the identified peaks with SiZer maps.\n\nfeature::SiZer(gmax_ks$Ks)\n\nWarning: no DISPLAY variable so Tk is not available\n\n\n\n\n\nWe can see that the 3 peaks are indeed supported, as indicated by the blue regions.\n\n\n\n\n\n\nExercises\n\n\n\nUse the output of find_ks_peaks() with the soybean data set to answer the following questions:\n\nWhat are the mean and standard deviation for the peaks?\nHow many gene pairs have Ks values between 0 and 0.4? What does that mean about the age of such gene pairs?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Q1\npeaks$mean\n\n        1         2         3 \n0.1177495 0.5308772 1.4811982 \n\npeaks$sd\n\n[1] 0.05488597 0.24418649 0.31357988\n\n# Q2\nlength(peaks$ks[peaks$ks &lt; 0.4])\n\n[1] 35269\n\n\nGenes with \\(K_s\\) between 0 and 0.4 are young, and those in this range that are present in syntenic regions have likely originated from a recent WGD event."
  },
  {
    "objectID": "gene_genome_duplication.html#references",
    "href": "gene_genome_duplication.html#references",
    "title": "5  Analysis of gene and genome duplication",
    "section": "References",
    "text": "References\n\n\n\n\nAlmeida-Silva, Fabricio, Tao Zhao, Kristian K Ullrich, M Eric Schranz, and Yves Van de Peer. 2023. “Syntenet: An r/Bioconductor Package for the Inference and Analysis of Synteny Networks.” Bioinformatics 39 (1): btac806.\n\n\nOhno, Susumu. 2013. Evolution by Gene Duplication. Springer Science & Business Media.\n\n\nWang, Dapeng, Yubin Zhang, Zhang Zhang, Jiang Zhu, and Jun Yu. 2010. “KaKs_calculator 2.0: A Toolkit Incorporating Gamma-Series Methods and Sliding Window Strategies.” Genomics, Proteomics & Bioinformatics 8 (1): 77–80."
  }
]