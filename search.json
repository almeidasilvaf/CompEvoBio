[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Computational Evolutionary Biology",
    "section": "",
    "text": "Preface\nThis book aims to provide learners with a hands-on introduction to Computational Evolutionary Biology, and the materials here are used in the practical lessons of the courses C003709A - Evolutionary Biology and C000500A - Bioinformatics 2 at Universiteit Gent, taught by Dr. Yves Van de Peer and Fabricio Almeida-Silva.\nEach book chapter represents the contents of a practical lesson from the UGent courses, and they serve both as a guide during the lessons and as a reference to go back later.\nThe book will cover:\n\nIntroduction to the R programming language\nMultiple Sequence Alignment\nPhylogenetic inference with maximum-likelihood\nAnalyses of gene and genome duplication"
  },
  {
    "objectID": "intro_to_R.html#goals-of-this-lesson",
    "href": "intro_to_R.html#goals-of-this-lesson",
    "title": "1  Introduction to R",
    "section": "1.1 Goals of this lesson",
    "text": "1.1 Goals of this lesson\nThis lesson was designed to be a gentle introduction to R for evolutionary genomics. Thus, we will only cover the basics of the language. An alternative name for this lesson could be “all you need to know about R to start your evolutionary analyses”. At the end of this lesson, you will be able to:\n\nperform simple mathematical operations in R\ncreate and modify objects\nuse functions and look for help\ncreate vectors and understand the difference between vector types\ncreate data frames\nsubset vectors and data frames"
  },
  {
    "objectID": "intro_to_R.html#creating-objects",
    "href": "intro_to_R.html#creating-objects",
    "title": "1  Introduction to R",
    "section": "1.2 Creating objects",
    "text": "1.2 Creating objects\nThe simplest use of R is to perform mathematical operations, which can be simply typed in the console:\n\n2 + 2\n\n[1] 4\n\n4 * 5\n\n[1] 20\n\n20 / 10\n\n[1] 2\n\n5 - 3\n\n[1] 2\n\n\nHowever, simple mathematical operations are not very useful. Typically, you would want to assign values to R objects. R objects can be created by using object_name + <- + value. The <- symbol is called the “assignment operator”, and it assigns values to objects. Example:\n\ngenome_size <- 2000000\n\nNote that when you assign a value to an object, nothing happens on the screen. In the example above, we created an object named genome_size that contains the value 2000000, but the value is not printed to screen. To show the contents of an object, you must type its name and execute it. For example:\n\ngenome_size\n\n[1] 2e+06\n\n\nAlternatively, we can assign values to objects AND print them at the same time by surrounding the assignment code with parentheses. For example:\n\n(genome_size <- 2000000)\n\n[1] 2e+06\n\n\n\n\n\n\n\n\nNaming objects\n\n\n\nAlthough you can give your objects whatever name you want, some general best practices include:\n\nChoose a descriptive name, but not too long.\nDo not use dots (.).\nUse nouns.\nBe consistent with your styling. Styles include snake case (e.g., phylo_tree) and camel case (e.g., phyloTree.)\n\nNote that object names cannot start with numbers.\n\n\nNow that we have an object genome_size with a value, we can use the object to perform mathematical operations. For example, let’s suppose we want to see the genome size in many thousands of base pairs (i.e., kbp, which stands for kilobase pairs):\n\ngenome_size / 1000\n\n[1] 2000\n\n\nWe can also change the value of an object by assigning a new value to it. For instance, let’s update the genome_size object with the size in kbp:\n\ngenome_size # original object\n\n[1] 2e+06\n\ngenome_size <- genome_size / 1000 # modifying the object\ngenome_size\n\n[1] 2000\n\n\nAs you can see, the object genome_size now contains the value 2000."
  },
  {
    "objectID": "intro_to_R.html#functions-and-arguments",
    "href": "intro_to_R.html#functions-and-arguments",
    "title": "1  Introduction to R",
    "section": "1.3 Functions and arguments",
    "text": "1.3 Functions and arguments\nFunctions are scripts that automate a particular task, and they typically have verbs in their names. They are made available to users as part of packages, and there are several R packages with specialized functions for each field. When you download and install R, it already comes with some packages installed, such as base and utils, but you can also install other packages depending on your needs.\nA function takes one or many arguments as input and return something as output. To execute a function in R, you need to write the function name followed by the arguments inside parenthesis. For example, let’s execute the function sqrt(), which takes a numeric value as input and return its square root:\n\nsqrt(100)\n\n[1] 10\n\n\nYou can also pass objects as input to functions. For example, let’s pass our object genome_size to the sqrt() function:\n\nsqrt(genome_size)\n\n[1] 44.72136\n\n\nTo see all the possible arguments a function takes, use the function args() with the function name as input. For example, let’s see all possible arguments for the round() function (which rounds up numbers):\n\nargs(round)\n\nfunction (x, digits = 0) \nNULL\n\n\nWe can see that the round() function can take two arguments as input: x, which is a numeric value, and digits, which indicates how many digits should be used when rounding values. Let’s try to execute the round() function with different options to digits.\n\npi <- 3.14159\nround(pi)\n\n[1] 3\n\nround(pi, digits = 2)\n\n[1] 3.14\n\nround(pi, digits = 3)\n\n[1] 3.142\n\n\nFinally, if you want to learn more about what a function does and how to use it, you can type the function name preceded by a question mark. For example:\n\n?round\n\nThis will open up a help page with detailed information on what the function does, its arguments, and examples.\n\n\n\n\n\n\nExercises\n\n\n\nThe genome of the plant Arabidopsis thaliana contains 33768 genes, of which 27655 are protein-coding and 6113 encode non-coding RNAs. Calculate the percentage of coding and non-coding genes in this genome using the following steps:\n\nCreate a variable named ath_genes that stores the numeric value 33768.\nCreate 2 objects named n_coding and n_noncoding that store the numeric values 27655 and 6113, respectively.\nCreate 2 objects named perc_coding and perc_noncoding by dividing n_coding and n_noncoding by ath_genes.\nUpdate the objects by multiplying their contents by 100 (to represent in percentages, from 0 to 100) and rounding the percentages to 1 significant digit only.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Store values in objects\nath_genes <- 33768\nn_coding <- 27655\nn_noncoding <- 6113\n\n# Get percentages\nperc_coding <- n_coding / ath_genes\nperc_noncoding <- n_noncoding / ath_genes\n\n# Update objects with actual percentages\nperc_coding <- round(perc_coding * 100, 1)\nperc_noncoding <- round(perc_noncoding * 100, 1)\n\n# Show contents of the objects\nperc_coding\n\n[1] 81.9\n\nperc_noncoding\n\n[1] 18.1"
  },
  {
    "objectID": "intro_to_R.html#data-structures",
    "href": "intro_to_R.html#data-structures",
    "title": "1  Introduction to R",
    "section": "1.4 Data structures",
    "text": "1.4 Data structures\nNow, we will explore two data structures in R that we will use all the time throughout the lessons (and in our research routine): vectors and data frames.\n\n1.4.1 Vectors\nVector are the most common data structures in R, and they are used to store multiple values. There are 6 kinds of values that can be stored in a vector, but the ones we typically use are:\n\nnumeric: numbers.\ncharacter: text strings.\nlogical: either TRUE or FALSE.\n\nThe other types are integer, complex, and raw, but they are not important here.\nTo create a vector, you will use the c() function to combine values. For example:\n\n# Creating a numeric vector\ngenome_sizes <- c(33768, 52872, 39756)\ngenome_sizes\n\n[1] 33768 52872 39756\n\n# Creating a character vector\nspecies <- c(\"Arabidopsis\", \"soybean\", \"maize\")\nspecies\n\n[1] \"Arabidopsis\" \"soybean\"     \"maize\"      \n\n\nYou can inspect vectors with the functions:\n\nclass(): shows the class of a vector.\nlength(): shows the number of elements in a vector.\nstr(): summarizes the structure of a vector.\n\n\nclass(genome_sizes)\n\n[1] \"numeric\"\n\nlength(genome_sizes)\n\n[1] 3\n\nstr(genome_sizes)\n\n num [1:3] 33768 52872 39756\n\n\nYou can also combine two vectors:\n\nspecies1 <- c(\"soybean\", \"maize\")\nspecies2 <- c(\"cotton\", \"bean\")\ncombined_species <- c(species1, species2)\ncombined_species\n\n[1] \"soybean\" \"maize\"   \"cotton\"  \"bean\"   \n\n\nNOTE: Vectors can only store values of the same type (i.e., character, numeric, etc). If you try to create a vector that contains values of different types, R converts them to all be the same type. This conversion of one class to another is called coercion. For example:\n\n# Creating a vector with numeric and character values\nc_vector <- c(\"a\", \"b\", 1, \"d\")\nc_vector\n\n[1] \"a\" \"b\" \"1\" \"d\"\n\n\nIn the example above, R converted the numeric value 1 to a character.\n\n\n1.4.2 Data frames\nData frames is the name R uses to call tables. To create a new data frame, you will use the data.frame() function. Each column of a data frame is a vector, so you can create a data frame by passing each vector to each column. For example, let’s recreate the genome_sizes and species vectors we created in the previous section and store them in columns genome_size and species of a data frame:\n\n# Create vectors again\ngenome_sizes <- c(33768, 52872, 39756)\nspecies <- c(\"Arabidopsis\", \"soybean\", \"maize\")\n\n# Create a data frame with columns `genome_size` and `species`\ngenome_size_df <- data.frame(\n    genome_size = genome_sizes,\n    species = species\n)\n\ngenome_size_df\n\n  genome_size     species\n1       33768 Arabidopsis\n2       52872     soybean\n3       39756       maize\n\n\nWe can also create the vectors inside the data.frame() function itself:\n\ngenome_size_df <- data.frame(\n    genome_size = c(33768, 52872, 39756),\n    species = c(\"Arabidopsis\", \"soybean\", \"maize\")\n)\n\ngenome_size_df\n\n  genome_size     species\n1       33768 Arabidopsis\n2       52872     soybean\n3       39756       maize\n\n\nTo add a column to an existing data frame, you have to add $ followed by the new column name in front of the object name. For example, let’s add a column named is_model to the genome_size_df data frame that indicates whether or not a species is a model species:\n\n# Add `is_model` column\ngenome_size_df$is_model <- c(TRUE, FALSE, FALSE)\ngenome_size_df\n\n  genome_size     species is_model\n1       33768 Arabidopsis     TRUE\n2       52872     soybean    FALSE\n3       39756       maize    FALSE\n\n\nFinally, to inspect a data frame, you can use the following functions:\n\ndim(): shows the dimensions of the data frame (i.e., number of rows and columns, respectively).\nnrow(): shows the number of rows in a data frame.\nncol(): shows the number of columns in a data frame.\nhead(): shows the first 6 rows of a data frame.\ntail(): shows the last 6 rows of a data frame.\nnames(): shows the column names.\nrownames(): shows the row names\nstr(): summarizes the structure of a data frame.\nsummary(): shows summary statistics for each column.\n\n\n\n\n\n\n\nExercises\n\n\n\n\nThe plants Brussels sprout, grapevine and apple belong to the families Brassicaceae, Vitaceae, and Rosaceae. Create a data frame named species_families with 2 columns named species and family representing such information.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nspecies_families <- data.frame(\n    species = c(\"Brussels sprout\", \"grapevine\", \"apple\"),\n    family = c(\"Brassicaceae\", \"Vitaceae\", \"Rosaceae\")\n)\n\nspecies_families\n\n          species       family\n1 Brussels sprout Brassicaceae\n2       grapevine     Vitaceae\n3           apple     Rosaceae\n\n\n\n\n\n\nWhen you install R, it already comes with some example data sets. One of them is airquality, a data frame containing New York air quality measurements from May to September 1973. Inspect this data frame and answer the following questions:\n\nHow many rows are there?\nHow many columns are there?\nWhat are the column names?\nWhat are the classes of each column?\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nstr(airquality)\n\n'data.frame':   153 obs. of  6 variables:\n $ Ozone  : int  41 36 12 18 NA 28 23 19 8 NA ...\n $ Solar.R: int  190 118 149 313 NA NA 299 99 19 194 ...\n $ Wind   : num  7.4 8 12.6 11.5 14.3 14.9 8.6 13.8 20.1 8.6 ...\n $ Temp   : int  67 72 74 62 56 66 65 59 61 69 ...\n $ Month  : int  5 5 5 5 5 5 5 5 5 5 ...\n $ Day    : int  1 2 3 4 5 6 7 8 9 10 ..."
  },
  {
    "objectID": "intro_to_R.html#indexing-and-subsetting",
    "href": "intro_to_R.html#indexing-and-subsetting",
    "title": "1  Introduction to R",
    "section": "1.5 Indexing and subsetting",
    "text": "1.5 Indexing and subsetting\nHere, you will learn how to extract specific elements of vectors and data frames, which is called subsetting.\n\n1.5.1 Vectors\nTo subset vectors, you need to pass the index of the element you want to extract inside square brackets ([]). If you want to extract multiple elements, you have to pass a vector of indices inside the square brackets. For example:\n\nplants <- c(\"rice\", \"maize\", \"duckweed\")\n\n# Extract 1st element\nplants[1]\n\n[1] \"rice\"\n\n# Extract 1st and 2nd element\nplants[c(1, 2)]\n\n[1] \"rice\"  \"maize\"\n\n# Extract 3rd and 2nd element (in this order)\nplants[c(3, 2)]\n\n[1] \"duckweed\" \"maize\"   \n\n\nYou can also remove a given element by adding a minus (-) symbol before the index:\n\n# Get all elements, except the 1st\nplants[-1]\n\n[1] \"maize\"    \"duckweed\"\n\n# Get all elements, except the 1st and 3rd\nplants[-c(1, 3)]\n\n[1] \"maize\"\n\n\nAnother very common way to subset vectors is by using logical vectors. When using logical vectors, TRUE and FALSE will indicate whether to extract or not extract the element. For example, let’s use logical vectors to subset the plants vector we created above:\n\nplants\n\n[1] \"rice\"     \"maize\"    \"duckweed\"\n\n# Extract 1st element, do not extract 2nd and 3rd elements\nplants[c(TRUE, FALSE, FALSE)]\n\n[1] \"rice\"\n\n# Extract 1st and 3rd elements, do not extract 2nd\nplants[c(TRUE, FALSE, TRUE)]\n\n[1] \"rice\"     \"duckweed\"\n\n\nNow, you might be thinking: using logical vectors seems complicated. Why would someone do this instead of using indices?. The answer is conditional subsetting. In R, you can use logical expressions that return TRUE or FALSE to extract elements. For example, let’s create a vector of genome sizes for fictional species and check if they more than 20,000 genes:\n\nngenes <- c(52000, 35000, 18000, 17000, 22000, 11000, 13000)\n\n# Logical expression: is the element >= 20000?\nngenes > 20000\n\n[1]  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE\n\n\nYou can see that the logical expression returns a vector of TRUEs and FALSEs. Since TRUE means extract and FALSE means do not extract when subsetting, we can use logical expressions to subset vectors as follows:\n\n# Extract elements with >=20000 genes\nngenes[ngenes > 20000]\n\n[1] 52000 35000 22000\n\n\nYou can combine multiple tests in logical expressions using & (which means AND, both conditions are true) and | (which means OR, at least one of the conditions is true).\n\n# Extract elements with number of genes between 20000 and 40000\nngenes[ngenes > 20000 & ngenes < 40000]\n\n[1] 35000 22000\n\n# Extract elements with 13000 or 11000 genes\nngenes[ngenes == 13000 | ngenes == 11000]\n\n[1] 11000 13000\n\n\nYou can also subset a vector based on the presence of some pre-defined elements using the %in% operator. For example:\n\nanimals <- c(\"dog\", \"cat\", \"rat\", \"pig\", \"horse\")\n\nanimals[animals %in% c(\"cat\", \"dog\")]\n\n[1] \"dog\" \"cat\"\n\n\n\n\n1.5.2 Data frames\nSubsetting data frames in very similar to subsetting vectors. The only difference is that data frames have 2 dimensions (rows and columns), while vectors have only 1 dimension. Thus, when you subset a data frame, you have to specify which dimension you want to use. For instance, if you execute vec[2], you will extract the 2nd element of the vector vec. However, if you pass the index 2 to a data frame, you can mean either the 2nd row or the second column. To subset data frames, you will use commas (,) inside square brackets to distinguish rows (which come before the comma) from columns (which come after the comma. For example:\n\n# See the first 6 rows the `airquality` data frame\nhead(airquality)\n\n  Ozone Solar.R Wind Temp Month Day\n1    41     190  7.4   67     5   1\n2    36     118  8.0   72     5   2\n3    12     149 12.6   74     5   3\n4    18     313 11.5   62     5   4\n5    NA      NA 14.3   56     5   5\n6    28      NA 14.9   66     5   6\n\n# Extract the element in row 1, column 2\nairquality[1, 2]\n\n[1] 190\n\n# Extract rows 1 to 5, column 1 - note: `1:5` is the same as `c(1, 2, 3, 4, 5)`\nairquality[1:5, 1]\n\n[1] 41 36 12 18 NA\n\n\nTo extract all rows or all columns, leave the corresponding field empty:\n\n# Extract row 2, all columns\nairquality[2, ]\n\n  Ozone Solar.R Wind Temp Month Day\n2    36     118    8   72     5   2\n\n# Extract column 2, all rows\nairquality[, 2]\n\n  [1] 190 118 149 313  NA  NA 299  99  19 194  NA 256 290 274  65 334 307  78\n [19] 322  44   8 320  25  92  66 266  NA  13 252 223 279 286 287 242 186 220\n [37] 264 127 273 291 323 259 250 148 332 322 191 284  37 120 137 150  59  91\n [55] 250 135 127  47  98  31 138 269 248 236 101 175 314 276 267 272 175 139\n [73] 264 175 291  48 260 274 285 187 220   7 258 295 294 223  81  82 213 275\n [91] 253 254  83  24  77  NA  NA  NA 255 229 207 222 137 192 273 157  64  71\n[109]  51 115 244 190 259  36 255 212 238 215 153 203 225 237 188 167 197 183\n[127] 189  95  92 252 220 230 259 236 259 238  24 112 237 224  27 238 201 238\n[145]  14 139  49  20 193 145 191 131 223\n\n\nYou can also subset columns based on their names:\n\nairquality$Month\n\n  [1] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6\n [38] 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7\n [75] 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n[112] 8 8 8 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9\n[149] 9 9 9 9 9\n\nairquality[, \"Month\"] # same thing\n\n  [1] 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6\n [38] 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7\n [75] 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8\n[112] 8 8 8 8 8 8 8 8 8 8 8 8 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9\n[149] 9 9 9 9 9\n\n\nAs we did with vectors, we can subset the data frame using logical expressions:\n\n# Extract rows for which column \"Month\" is equal to 5\nairquality[airquality$Month == 5, ]\n\n   Ozone Solar.R Wind Temp Month Day\n1     41     190  7.4   67     5   1\n2     36     118  8.0   72     5   2\n3     12     149 12.6   74     5   3\n4     18     313 11.5   62     5   4\n5     NA      NA 14.3   56     5   5\n6     28      NA 14.9   66     5   6\n7     23     299  8.6   65     5   7\n8     19      99 13.8   59     5   8\n9      8      19 20.1   61     5   9\n10    NA     194  8.6   69     5  10\n11     7      NA  6.9   74     5  11\n12    16     256  9.7   69     5  12\n13    11     290  9.2   66     5  13\n14    14     274 10.9   68     5  14\n15    18      65 13.2   58     5  15\n16    14     334 11.5   64     5  16\n17    34     307 12.0   66     5  17\n18     6      78 18.4   57     5  18\n19    30     322 11.5   68     5  19\n20    11      44  9.7   62     5  20\n21     1       8  9.7   59     5  21\n22    11     320 16.6   73     5  22\n23     4      25  9.7   61     5  23\n24    32      92 12.0   61     5  24\n25    NA      66 16.6   57     5  25\n26    NA     266 14.9   58     5  26\n27    NA      NA  8.0   57     5  27\n28    23      13 12.0   67     5  28\n29    45     252 14.9   81     5  29\n30   115     223  5.7   79     5  30\n31    37     279  7.4   76     5  31\n\n# Extract rows with \"Temp\" >90, then show only columns \"Month\" and \"Day\"\nairquality[airquality$Temp > 90, c(\"Month\", \"Day\")]\n\n    Month Day\n42      6  11\n43      6  12\n69      7   8\n70      7   9\n75      7  14\n102     8  10\n120     8  28\n121     8  29\n122     8  30\n123     8  31\n124     9   1\n125     9   2\n126     9   3\n127     9   4\n\n\n\n\n\n\n\n\nExercises\n\n\n\nSubset the airquality data set to answer the following questions:\n\nHow many days (rows) observations have ozone levels >40 ppb?\nHow many days have wind speed between 10 and 15 mph?\nWhat are the minimum and maximum temperature?\nHow many days have solar radiation <100 Langleys?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Q1: Ozone levels >40 ppb\nnrow(airquality[airquality$Ozone > 40, ])\n\n[1] 82\n\n# Q2: Wind speed between 10 and 15 mph\nnrow(airquality[airquality$Wind >= 10 & airquality$Wind <=15, ])\n\n[1] 62\n\n# Q3: Minimum and maximum temperature\nsummary(airquality)\n\n     Ozone           Solar.R           Wind             Temp      \n Min.   :  1.00   Min.   :  7.0   Min.   : 1.700   Min.   :56.00  \n 1st Qu.: 18.00   1st Qu.:115.8   1st Qu.: 7.400   1st Qu.:72.00  \n Median : 31.50   Median :205.0   Median : 9.700   Median :79.00  \n Mean   : 42.13   Mean   :185.9   Mean   : 9.958   Mean   :77.88  \n 3rd Qu.: 63.25   3rd Qu.:258.8   3rd Qu.:11.500   3rd Qu.:85.00  \n Max.   :168.00   Max.   :334.0   Max.   :20.700   Max.   :97.00  \n NA's   :37       NA's   :7                                       \n     Month            Day      \n Min.   :5.000   Min.   : 1.0  \n 1st Qu.:6.000   1st Qu.: 8.0  \n Median :7.000   Median :16.0  \n Mean   :6.993   Mean   :15.8  \n 3rd Qu.:8.000   3rd Qu.:23.0  \n Max.   :9.000   Max.   :31.0  \n                               \n\n# Q4: Solar radiation <100 Langleys\nnrow(airquality[airquality$Solar.R < 100, ])\n\n[1] 41"
  },
  {
    "objectID": "data_structures_genomics.html#the-bioconductor-ecosystem",
    "href": "data_structures_genomics.html#the-bioconductor-ecosystem",
    "title": "2  R for evolutionary biology: data structures",
    "section": "2.1 The Bioconductor ecosystem",
    "text": "2.1 The Bioconductor ecosystem\nThe Bioconductor project was created to develop, support, and disseminate free open source software to analyze biological data. It works as a repository of R packages for biological data analysis, with both “core packages” (developed and maintained by the Bioconductor Core Team), and community-contributed packages. We usually refer to Bioconductor as a “package ecosystem” because its packages are tightly integrated and designed for easy interoperation, such that different packages can be used together with minimal effort. An important facilitator of such interoperability is the existence of standardized data structures, such as GRanges objects for genomic coordinates, and DNA/RNA/AAStringSet objects for sequences.\n\n2.1.1 The {Biostrings} package and XStringSet objects\nThe Biostrings package (Pagès et al. 2022) allows efficient manipulation of biological sequences, and its data classes are standard for all Bioconductor packages that involve sequence analyses. The data classes in Biostrings to represent sets of biological sequences are:\n\nDNAStringSet: for sets of DNA strings.\nRNAStringSet: for sets of RNA strings.\nAAStringSet: for sets of amino acid strings.\n\nFor a single sequence, the each of the above has a correspoding XString class (i.e., DNAString, RNAString, AAString). For example, let’s create some XString objects manually:\n\nlibrary(Biostrings)\n\n# Create `DNAString` object\ndna_seq <- DNAString(\"ATGGCCGACTCA\")\ndna_seq\n\n12-letter DNAString object\nseq: ATGGCCGACTCA\n\n# Convert `DNAString` to `RNAString`\nrna_seq <- RNAString(dna_seq)\nrna_seq\n\n12-letter RNAString object\nseq: AUGGCCGACUCA\n\n# Translate `RNAString` to create `AAString`\naa_seq <- translate(rna_seq)\naa_seq\n\n4-letter AAString object\nseq: MADS\n\n\nIn real-world data analyses, we would work with multiple sequences (e.g., a whole genome or a whole proteome). Multiple sequences are stored in XStringSet objects, which can be read from FASTA files with readXStringSet() functions, namely:\n\nreadDNAStringSet(): read FASTA file containing multiple DNA sequences.\nreadRNAStringSet(): read FASTA file containing multiple RNA sequences.\nreadAAStringSet(): read FASTA file containing multiple AA sequences.\n\nFor example, let’s read an example FASTA file that come with the Biostrings package.\n\n# Path to FASTA file containing an ORF\nfasta_file <- system.file(\"extdata\", \"someORF.fa\", package = \"Biostrings\")\nfasta_file\n\n[1] \"/home/runner/work/_temp/Library/Biostrings/extdata/someORF.fa\"\n\n# Read FASTA file as a DNAStringSet object\ndna_seqs <- readDNAStringSet(fasta_file)\ndna_seqs\n\nDNAStringSet object of length 7:\n    width seq                                               names               \n[1]  5573 ACTTGTAAATATATCTTTTATTT...CTTATCGACCTTATTGTTGATAT YAL001C TFC3 SGDI...\n[2]  5825 TTCCAAGGCCGATGAATTCGACT...AGTAAATTTTTTTCTATTCTCTT YAL002W VPS8 SGDI...\n[3]  2987 CTTCATGTCAGCCTGCACTTCTG...TGGTACTCATGTAGCTGCCTCAT YAL003W EFB1 SGDI...\n[4]  3929 CACTCATATCGGGGGTCTTACTT...TGTCCCGAAACACGAAAAAGTAC YAL005C SSA1 SGDI...\n[5]  2648 AGAGAAAGAGTTTCACTTCTTGA...ATATAATTTATGTGTGAACATAG YAL007C ERP2 SGDI...\n[6]  2597 GTGTCCGGGCCTCGCAGGCGTTC...AAGTTTTGGCAGAATGTACTTTT YAL008W FUN14 SGD...\n[7]  2780 CAAGATAATGTCAAAGTTAGTGG...GCTAAGGAAGAAAAAAAAATCAC YAL009W SPO7 SGDI...\n\n\nSome examples of what you can do to explore XStringSet objects include:\n\n# width(): get sequence lengths\nwidth(dna_seqs)\n\n[1] 5573 5825 2987 3929 2648 2597 2780\n\n# names(): get sequence names\nnames(dna_seqs)\n\n[1] \"YAL001C TFC3 SGDID:S0000001, Chr I from 152168-146596, reverse complement, Verified ORF\"\n[2] \"YAL002W VPS8 SGDID:S0000002, Chr I from 142709-148533, Verified ORF\"                    \n[3] \"YAL003W EFB1 SGDID:S0000003, Chr I from 141176-144162, Verified ORF\"                    \n[4] \"YAL005C SSA1 SGDID:S0000004, Chr I from 142433-138505, reverse complement, Verified ORF\"\n[5] \"YAL007C ERP2 SGDID:S0000005, Chr I from 139347-136700, reverse complement, Verified ORF\"\n[6] \"YAL008W FUN14 SGDID:S0000006, Chr I from 135916-138512, Verified ORF\"                   \n[7] \"YAL009W SPO7 SGDID:S0000007, Chr I from 134856-137635, Verified ORF\"                    \n\n# subset DNAStringSet and create a DNAStringSet of length 1\ndna_seqs[1]\n\nDNAStringSet object of length 1:\n    width seq                                               names               \n[1]  5573 ACTTGTAAATATATCTTTTATTT...CTTATCGACCTTATTGTTGATAT YAL001C TFC3 SGDI...\n\n# subset DNAStringSet and create a DNAString object\ndna_seqs[[1]]\n\n5573-letter DNAString object\nseq: ACTTGTAAATATATCTTTTATTTTCCGAGAGGAAAA...AATTTCTTAAACGCTTATCGACCTTATTGTTGATAT\n\n\nAll functions above would also work for AAStringSet objects and RNAStringSet objects.\n\n\n\n\n\n\nExercises\n\n\n\nUse the dna_seqs object created above to answer the following questions:\n\nWhat is the length of the 3rd sequence?\nWhat is the name of the 5th sequence?\nHow many times does the TTCC sequence string occur in each sequence? Hint: use the function vcountPattern().\nWhat are the first 3 nucleotides of each sequence? Hint: use the subseq() function.\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Q1: Length of the 3rd sequence\nwidth(dna_seqs)[3]\n\n[1] 2987\n\n# Q2: Name of the 5th sequence\nnames(dna_seqs)[5]\n\n[1] \"YAL007C ERP2 SGDID:S0000005, Chr I from 139347-136700, reverse complement, Verified ORF\"\n\n# Q3: Minimum and maximum temperature\nvcountPattern(\"TTCC\", dna_seqs)\n\n[1] 21 28 16 23 15  8  5\n\n# Q4: First 3 nucleotides of each sequence\nsubseq(dna_seqs, start = 1, end = 3)\n\nDNAStringSet object of length 7:\n    width seq                                               names               \n[1]     3 ACT                                               YAL001C TFC3 SGDI...\n[2]     3 TTC                                               YAL002W VPS8 SGDI...\n[3]     3 CTT                                               YAL003W EFB1 SGDI...\n[4]     3 CAC                                               YAL005C SSA1 SGDI...\n[5]     3 AGA                                               YAL007C ERP2 SGDI...\n[6]     3 GTG                                               YAL008W FUN14 SGD...\n[7]     3 CAA                                               YAL009W SPO7 SGDI...\n\n\n\n\n\n\n\n\n\n2.1.2 The {Biostrings} package and XMultipleAlignment objects\nLike XStringSet objects, XMultipleAlignment objects also store sequences, but sequences that were aligned using a Sequence Alignment algorithm. FASTA files containing aligned sequences can be read with XMultipleAlignment functions, namely:\n\nreadDNAMultipleAlignment(): read a FASTA file containing aligned DNA sequences.\nreadRNAMultipleAlignment(): read a FASTA file containing aligned RNA sequences.\nreadAAMultipleAlignment(): read a FASTA file containing aligned amino acid sequences.\n\nFor example:\n\n# Path to FASTA file containing MSA of DNA sequences\naln_path <- system.file(\"extdata\", \"msx2_mRNA.aln\", package = \"Biostrings\")\naln_path\n\n[1] \"/home/runner/work/_temp/Library/Biostrings/extdata/msx2_mRNA.aln\"\n\n# Read MSA file\ndna_msa <- readDNAMultipleAlignment(aln_path)\ndna_msa\n\nDNAMultipleAlignment with 8 rows and 2343 columns\n     aln                                                    names               \n[1] -----TCCCGTCTCCGCAGCAAAAAA...TCACAATTAAAAAAAAAAAAAAAAA gi|84452153|ref|N...\n[2] --------------------------...------------------------- gi|208431713|ref|...\n[3] --------------------------...------------------------- gi|118601823|ref|...\n[4] ----------------------AAAA...------------------------- gi|114326503|ref|...\n[5] --------------------------...------------------------- gi|119220589|ref|...\n[6] --------------------------...------------------------- gi|148540149|ref|...\n[7] --------------CGGCTCCGCAGC...------------------------- gi|45383056|ref|N...\n[8] GGGGGAGACTTCAGAAGTTGTTGTCC...------------------------- gi|213515133|ref|...\n\n\n\n\n\n\n\n\nExercises\n\n\n\nWhat is the consensus sequence of the multiple sequence alignment in dna_msa? Hint: use the consensusString() function.\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\nconsensusString(dna_msa)\n\n[1] \"----------------------VWVMKYYBSRSTSDYVVMDKBHSVGHKSMSVRYVKDRYHRHKVSBYDNVVRVYWMSYNGVRCRGABAMGTCA-YRGCTTCTCYGTSCAWAGGCRRTGRCYTGTTYTCGYCCRRYGARGAGGGCCCVGCRGTKSTSGCCSGMCSRGGCCCVGGGCCYGGRGGMGCCGAGGGVGSCGMRGAGGAGCRCMRSGTCAAGGTCTCCAGCYTGCCCTTCAGYGTGGAGGCGCTCATGTCSGACAAGAARCCGCCYAAGGARKCGYCSSCGSKGCCRSCCGAMWGCGSCTCSGCYGGSGCYRYCCTGSGG----CCR-----CTGCTGCTGYCGGGVCACGGCGYYCGG-GAMGCKCMCAGYCCC---GGGCCKCTSGTSAARMCCTTCGAGACCGCCTCGGTCAAGTCGGARAAYTCMGARGAYGGARCGBCGTGGATVCAGGARCCCGGCMGATAYTCSCCKCCGCCMAGACAYATGAGCCCYACMRCCTGCACCCTGMGGAARCACAAGACCAAYCGGAAGCCVCGCACVCCCTTYACCACRTCCCAGCTYCTVGCCYTGGAGCGCAAGTTCCGYCAGAAACAGTACCTSTCCATYGCAGAGCGKGCMGAGTTCTCCAGCTCYCTGAACCTYACAGAGACCCAGGTCAAAATCTGGTTCCARAAYCGAAGGGCYAAGGCSAARAGACTGCAGGAGGCRGARCTRGARAAGCTSAARATGGCTGCMAARCCTATGYTGCCCTCVRGCTTCAGYCTBCCYTTCCCYATCARCTCSCCCYTGCARGCRGCRTCCMTATAYGGMRCRTCYTACCCBTTYCATAGACCTGTGC---TYCCYATCCCGCCYGT-BGGACTCTATGCSACBCCRGTSGGATATRGCATGTACCAYCTRTCCTAAGGAAGACCAGATSRRY-MGACTCCAGGATGGRTGWYTGYYTRAWAGMMTYYCCCNTCCMKCTYCRAGAAKGCRGTRCCAAYYY-TRSWMCTGMA-YGCWARCYYTGCRT-YGTCACCCTAASCRDCWRGGCTG--RCAGGRCYACWYGAYAYAGADBVAATTTGTTMTKTAGGYRRSAGRCACY-AAGMCYKGKTTTSTTKKYATARTYYYCYRRRTGC--CCCCTTTTCCYYTCASARW-KATTGGCTCTGMTAGTTTTTATGTATAAATATATA------ATAAAATATAAKAC--TTTTTATAYRSCARATGTAAAAATTCAAVYTRTKYTRDAW--GSCAAARTTTRTWKRHWYRYKTVBYHDKWTW---------YVTRKVTMDSMTYHYYHHMWRAHWHYSWGW-WAGYYC---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\""
  },
  {
    "objectID": "data_structures_genomics.html#the-ape-package-and-phylo-objects",
    "href": "data_structures_genomics.html#the-ape-package-and-phylo-objects",
    "title": "2  R for evolutionary biology: data structures",
    "section": "2.2 The {ape} package and phylo objects",
    "text": "2.2 The {ape} package and phylo objects\nThe ape package (Paradis and Schliep 2019) is one of the most popular packages for Analyses of Phylogenetics and Evolution (from where the name comes), and it represents phylogenies as phylo objects. Because of ape’s popularity, phylo objects have become the standard data structure for phylogenies in R.\nTo create phylo objects, you will use the function read.tree(), which accepts both the path to a file containing the tree (in Newick format, for example), or a text representation of a phylogeny. To demonstrate the structure of a phylo object, let’s create a phylogeny from text:\n\nlibrary(ape)\n\n# Create tree from text\ntext_tree <- \"((((cow, pig),whale), (bat, (lemur, human))), iguana);\"\ntree <- read.tree(text = text_tree)\n\ntree\n\n\nPhylogenetic tree with 7 tips and 6 internal nodes.\n\nTip labels:\n  cow, pig, whale, bat, lemur, human, ...\n\nRooted; no branch lengths.\n\n\nThis is what a phylo object looks like. In a sense, a phylo object is a list, a standard R data structure, but with some standard elements. Let’s explore them:\n\n# Structure of the `phylo` object\nstr(tree)\n\nList of 3\n $ edge     : int [1:12, 1:2] 8 9 10 11 11 10 9 12 12 13 ...\n $ Nnode    : int 6\n $ tip.label: chr [1:7] \"cow\" \"pig\" \"whale\" \"bat\" ...\n - attr(*, \"class\")= chr \"phylo\"\n - attr(*, \"order\")= chr \"cladewise\"\n\n# Exploring each element individually\ntree$edge\n\n      [,1] [,2]\n [1,]    8    9\n [2,]    9   10\n [3,]   10   11\n [4,]   11    1\n [5,]   11    2\n [6,]   10    3\n [7,]    9   12\n [8,]   12    4\n [9,]   12   13\n[10,]   13    5\n[11,]   13    6\n[12,]    8    7\n\ntree$Nnode\n\n[1] 6\n\ntree$tip.label\n\n[1] \"cow\"    \"pig\"    \"whale\"  \"bat\"    \"lemur\"  \"human\"  \"iguana\"\n\n\nAs phylo objects have become standard, there are hundreds of functions (from dozens of packages) that were especially designed to work on phylo objects. For example, if you want to plot the tree, you would use the plot() function:\n\n# Plot tree\nplot(tree)\n\n\n\n\nWe will explore other examples in future lessons.\n\n\n\n\n\n\nExercises\n\n\n\nUse the following code to simulate a random tree and answer the questions below:\n\nset.seed(123) # for reproducibility\nsim_tree <- rtree(n = 20)\n\n\nHow many terminal taxa (i.e., tips) are there?\nWhat the the names of terminal taxa?\nWhat taxon is more closely-related to the taxon “t1”?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Q1: Number of terminal taxa\nNtip(sim_tree)\n\n[1] 20\n\n# Q2: Names of terminal taxa\nsim_tree$tip.label\n\n [1] \"t5\"  \"t19\" \"t9\"  \"t3\"  \"t8\"  \"t10\" \"t7\"  \"t15\" \"t18\" \"t17\" \"t4\"  \"t1\" \n[13] \"t11\" \"t14\" \"t20\" \"t13\" \"t16\" \"t2\"  \"t12\" \"t6\" \n\n# Q3: Visualizing the tree to check who is more closely-related to 't1'\nplot(sim_tree)\n\n\n\n\n\n\n\n\n\n\n\n\n\nPagès, H., P. Aboyoun, R. Gentleman, and S. DebRoy. 2022. Biostrings: Efficient Manipulation of Biological Strings. https://bioconductor.org/packages/Biostrings.\n\n\nParadis, Emmanuel, and Klaus Schliep. 2019. “Ape 5.0: An Environment for Modern Phylogenetics and Evolutionary Analyses in R.” Bioinformatics 35: 526–28. https://doi.org/10.1093/bioinformatics/bty633."
  },
  {
    "objectID": "phylogeny_inference_distance.html",
    "href": "phylogeny_inference_distance.html",
    "title": "3  Distance-based phylogeny inference",
    "section": "",
    "text": "TBA."
  },
  {
    "objectID": "phylogeny_inference_ml.html#goals-of-this-lesson",
    "href": "phylogeny_inference_ml.html#goals-of-this-lesson",
    "title": "4  Maximum likelihood-based phylogeny inference",
    "section": "4.1 Goals of this lesson",
    "text": "4.1 Goals of this lesson\nTo demonstrate how to use IQ-TREE, we will use an example data set to explore a question that used to be hotly debated years ago:\n\nAre turtles more closely-related to birds or to crocodiles?\n\nThere are 3 hypotheses to test, and here we will use maximum-likelihood-based methods to find out which one is true:\n\n\n\n\n\nIn this lesson, you will learn to:\n\nInfer a maximum likelihood tree\nApply partition models and choose the best partitioning schemes\nPerform tree topology tests\nIdentify and remove influential genes\nCalculate concordance factors"
  },
  {
    "objectID": "phylogeny_inference_ml.html#data-description",
    "href": "phylogeny_inference_ml.html#data-description",
    "title": "4  Maximum likelihood-based phylogeny inference",
    "section": "4.2 Data description",
    "text": "4.2 Data description\nThe data we will use in this lesson were obtained from Chiari et al. (2012), and they are stored in the data/ directory associated with this course. The files we will use are:\n\nturtle.fa: a multiple sequence alignment (in FASTA) of a subset of the genes used in the original publication.\nturtle.nex: a partition file (in NEXUS) defining a subset of 29 genes."
  },
  {
    "objectID": "phylogeny_inference_ml.html#inferring-a-maximum-likelihood-tree",
    "href": "phylogeny_inference_ml.html#inferring-a-maximum-likelihood-tree",
    "title": "4  Maximum likelihood-based phylogeny inference",
    "section": "4.3 Inferring a maximum likelihood tree",
    "text": "4.3 Inferring a maximum likelihood tree\nTo run IQ-TREE, use the command below:\n\niqtree2 -s data/turtle.fa -B 1000 -T 2\n\n\n\n\n\n\n\nUnderstanding the command-line arguments\n\n\n\nThe argument -s is mandatory, and this is where you indicate where the file containing the MSA is. In our previous command, iqtree2 -s data/turtle.fa means “run IQ-TREE using the MSA in the file data/turtle.fa”.\nThe other arguments and their meanings are:\n\n-B: number of replicates for the ultrafast bootstrap (see Minh, Nguyen, and Von Haeseler (2013) for details). Here, we used 1000 replicates.\n-T: number of CPU cores to use. Here, we’re using 2 cores, because IQ-TREE defaults to using all available cores.\n\nFor a complete list of arguments and the possible values they take, run iqtree2 -h.\n\n\nThe main IQ-TREE report will be stored in a file ending in .iqtree, and the maximum likelihood tree (in Newick format) will be stored in a file ending in .treefile.\n\n\n\n\n\n\nExercises\n\n\n\nLook at the report file in data/turtle.fa.iqtree and answer the following questions:\n\nWhat is the best-fit model name?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ngrep \"Best-fit model\" data/turtle.fa.iqtree\n\nBest-fit model according to BIC: GTR+F+R3\n\n\n\n\n\n\nWhat are the AIC/AICc/BIC scores of this model and tree?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ngrep \"^Model  \\|^GTR+F+R3\" data/turtle.fa.iqtree\n\nModel                  LogL         AIC      w-AIC        AICc     w-AICc         BIC      w-BIC\nGTR+F+R3        -116218.179  232518.358 - 0.000395  232518.524 - 0.000398  232844.049 +    0.527\n\n\n\n\n\n\nVisualise the tree in data/turtle.fa.treefile. What relationship among three trees does this tree support? What is the ultrafast bootstrap support (%) for the relevant clade?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ntree <- read.tree(here(\"data\", \"turtle.fa.treefile\"))\n\nggtree(tree) +\n    geom_tiplab() +\n    xlim(0, 0.4) +\n    geom_nodelab(hjust = 1.3, vjust = -0.4)\n\n\n\n\nThis tree supports the “C” hypothesis, which positions turtles as a sister group to crocodiles. i.e., ((Turtle, Crocodile), Bird). The branch showing that turtles are a sister group to crocodiles has a bootstrap support of 82%.\n\n\n\n\nIn the figure below, you can see the tree published by Chiari et al. (2012). Does the inferred tree agree with the published tree?\n\n\n\n\nSpecies tree inferred by Chiari et al, 2012\n\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nNo. The published tree shows turtles are a sister group to birds and crocodiles (hypothesis A), while the inferred shows turtles as a sister group to crocodiles (hypothesis C)."
  },
  {
    "objectID": "phylogeny_inference_ml.html#applying-partition-models",
    "href": "phylogeny_inference_ml.html#applying-partition-models",
    "title": "4  Maximum likelihood-based phylogeny inference",
    "section": "4.4 Applying partition models",
    "text": "4.4 Applying partition models\nNow, we will infer a ML tree applying a partition model (Chernomor, Von Haeseler, and Minh 2016), which means that each partition (specified in the turtle.nex file) will be allowed to have its own model.\n\niqtree2 -s data/turtle.fa -p data/turtle.nex -B 1000 -T 2\n\n\n\n\n\n\n\nUnderstanding the command-line arguments\n\n\n\nThe only new argument here is -p turtle.nex, which is used to specify an edge-linked proportional partition model, so that each partition can have shorter or longer tree length (i.e., slower or faster evolutionary rates, respectively).\n\n\nAs in the simpler IQ-TREE run, the main report is in a file ending in .nex.iqtree, and the tree is in a file named .nex.treefile.\n\n\n\n\n\n\nExercises\n\n\n\n\nLook at the report file in data/turtle.nex.iqtree. What are the AIC/AICc/BIC scores of the partition model? Is it better than the previous model?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\n# Take a look at the best models per partition\ngrep \"Best-fit model\" data/turtle.nex.iqtree\n\n# See the AIC/AICc/BIC scores per partition\ngrep -A 30 \"List of best-fit models per partition\" data/turtle.nex.iqtree\n\nBest-fit model according to BIC: K2P+I+G4:ENSGALG00000000223.macse_DNA_gb,K2P+G4:ENSGALG00000001529.macse_DNA_gb,TN+F+G4:ENSGALG00000002002.macse_DNA_gb,TVM+F+I+G4:ENSGALG00000002514.macse_DNA_gb,TIM2e+I+G4:ENSGALG00000003337.macse_DNA_gb,TIM2+F+G4:ENSGALG00000003700.macse_DNA_gb,TN+F+G4:ENSGALG00000003702.macse_DNA_gb,K2P+I+G4:ENSGALG00000003907.macse_DNA_gb,TNe+I:ENSGALG00000005820.macse_DNA_gb,TIM2+F+G4:ENSGALG00000005834.macse_DNA_gb,TNe+G4:ENSGALG00000005902.macse_DNA_gb,TIM3e+G4:ENSGALG00000008338.macse_DNA_gb,TPM2+F+G4:ENSGALG00000008517.macse_DNA_gb,TPM2+F+I+G4:ENSGALG00000008916.macse_DNA_gb,TIM2+F+R3:ENSGALG00000009085.macse_DNA_gb,TN+F+G4:ENSGALG00000009879.macse_DNA_gb,TPM3+F+G4:ENSGALG00000011323.macse_DNA_gb,TIM3e+I+G4:ENSGALG00000011434.macse_DNA_gb,TIM3+F+G4:ENSGALG00000011917.macse_DNA_gb,K2P+G4:ENSGALG00000011966.macse_DNA_gb,SYM+G4:ENSGALG00000012244.macse_DNA_gb,TN+F+G4:ENSGALG00000012379.macse_DNA_gb,TNe+G4:ENSGALG00000012568.macse_DNA_gb,TPM2+F+G4:ENSGALG00000013227.macse_DNA_gb,TN+F+G4:ENSGALG00000014038.macse_DNA_gb,TN+F+G4:ENSGALG00000014648.macse_DNA_gb,TIM+F+G4:ENSGALG00000015326.macse_DNA_gb,TIM2+F+G4:ENSGALG00000015397.macse_DNA_gb,TPM2+F+I+G4:ENSGALG00000016241.macse_DNA_gb\nList of best-fit models per partition:\n\n  ID  Model                  LogL         AIC      w-AIC        AICc     w-AICc         BIC      w-BIC\n   1  K2P+I+G4          -5095.247   10198.494 + 1.42e-316   10198.541 + 5.45e-317   10217.456 + 1.24e-316\n   2  K2P+G4            -3419.486    6844.972 + 1.42e-316    6845.018 + 5.45e-317    6857.745 + 1.24e-316\n   3  TN+F+G4           -3609.176    7232.351 + 1.42e-316    7232.520 + 5.45e-317    7263.923 + 1.24e-316\n   4  TVM+F+I+G4        -4289.021    8598.043 + 1.42e-316    8598.348 + 5.45e-317    8644.001 + 1.24e-316\n   5  TIM2e+I+G4        -6224.713   12461.426 + 1.42e-316   12461.514 + 5.45e-317   12490.665 + 1.24e-316\n   6  TIM2+F+G4         -4719.062    9454.125 + 1.42e-316    9454.289 + 5.45e-317    9492.409 + 1.24e-316\n   7  TN+F+G4           -7633.586   15281.172 + 1.42e-316   15281.244 + 5.45e-317   15318.571 + 1.24e-316\n   8  K2P+I+G4          -2959.348    5926.696 + 1.42e-316    5926.780 + 5.45e-317    5943.391 + 1.24e-316\n   9  TNe+I             -3109.902    6227.805 + 1.42e-316    6227.875 + 5.45e-317    6245.229 + 1.24e-316\n  10  TIM2+F+G4         -3040.697    6097.394 + 1.42e-316    6097.604 + 5.45e-317    6133.757 + 1.24e-316\n  11  TNe+G4            -2864.568    5737.135 + 1.42e-316    5737.206 + 5.45e-317    5754.518 + 1.24e-316\n  12  TIM3e+G4          -5169.589   10349.179 + 1.42e-316   10349.255 + 5.45e-317   10372.552 + 1.24e-316\n  13  TPM2+F+G4         -2702.092    5418.183 + 1.42e-316    5418.394 + 5.45e-317    5448.224 + 1.24e-316\n  14  TPM2+F+I+G4       -3667.885    7351.771 + 1.42e-316    7352.039 + 5.45e-317    7386.192 + 1.24e-316\n  15  TIM2+F+R3         -4532.069    9086.138 + 1.42e-316    9086.426 + 5.45e-317    9139.325 + 1.24e-316\n  16  TN+F+G4           -4173.396    8360.792 + 1.42e-316    8360.982 + 5.45e-317    8391.535 + 1.24e-316\n  17  TPM3+F+G4         -5262.146   10538.293 + 1.42e-316   10538.418 + 5.45e-317   10571.909 + 1.24e-316\n  18  TIM3e+I+G4        -3036.049    6084.098 + 1.42e-316    6084.289 + 5.45e-317    6108.713 + 1.24e-316\n  19  TIM3+F+G4         -4092.671    8201.341 + 1.42e-316    8201.490 + 5.45e-317    8240.450 + 1.24e-316\n  20  K2P+G4            -2968.726    5943.452 + 1.42e-316    5943.504 + 5.45e-317    5955.897 + 1.24e-316\n  21  SYM+G4            -4372.436    8758.871 + 1.42e-316    8759.022 + 5.45e-317    8791.240 + 1.24e-316\n  22  TN+F+G4           -2870.272    5754.543 + 1.42e-316    5754.763 + 5.45e-317    5784.307 + 1.24e-316\n  23  TNe+G4            -2919.575    5847.149 + 1.42e-316    5847.213 + 5.45e-317    5864.932 + 1.24e-316\n  24  TPM2+F+G4         -5568.175   11150.350 + 1.42e-316   11150.437 + 5.45e-317   11186.552 + 1.24e-316\n  25  TN+F+G4           -3315.859    6645.717 + 1.42e-316    6645.920 + 5.45e-317    6676.025 + 1.24e-316\n  26  TN+F+G4           -2097.847    4209.693 + 1.42e-316    4209.922 + 5.45e-317    4239.168 + 1.24e-316\n  27  TIM+F+G4          -3743.957    7503.913 + 1.42e-316    7504.158 + 5.45e-317    7539.049 + 1.24e-316\n  28  TIM2+F+G4         -3634.194    7284.388 + 1.42e-316    7284.634 + 5.45e-317    7319.483 + 1.24e-316\n\n\nScores are better (lower BIC scores, for instance).\n\n\n\n\nVisualize the tree in data/turtle.nex.treefile. What relationship among three trees does this tree support? What is the ultrafast bootstrap support (%) for the relevant clade?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ntree <- read.tree(here(\"data\", \"turtle.nex.treefile\"))\n\nggtree(tree) +\n    geom_tiplab() +\n    xlim(0, 0.4) +\n    geom_nodelab(hjust = 1.3, vjust = -0.4)\n\n\n\n\nThe tree supports the “A” hypothesis, which positions turtles as a sister group to birds and crocodiles. The branch showing that turtles are a sister group to crocodiles has a bootstrap support of 100%.\n\n\n\n\nDoes the inferred tree agree with the published tree (Chiari et al. 2012)?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nYes. Both trees agree on the “A” hypothesis."
  },
  {
    "objectID": "phylogeny_inference_ml.html#selecting-the-best-partitioning-scheme-with-partitionfinder",
    "href": "phylogeny_inference_ml.html#selecting-the-best-partitioning-scheme-with-partitionfinder",
    "title": "4  Maximum likelihood-based phylogeny inference",
    "section": "4.5 Selecting the best partitioning scheme with PartitionFinder",
    "text": "4.5 Selecting the best partitioning scheme with PartitionFinder\nNow, we will use PartitionFinder (Lanfear et al. 2012) to merge partitions and reduce the potential over-parameterization.\n\niqtree2 -s data/turtle.fa -p data/turtle.nex -B 1000 -T 2 -m MFP+MERGE -rcluster 10 --prefix data/turtle.merge\n\n\n\n\n\n\n\nUnderstanding the command-line arguments\n\n\n\nBesides the arguments we’ve already seen, the new arguments and their meanings are:\n\n-m: specifies the model to use. Here, MFP+MERGE indicates running PartitionFinder followed by tree reconstruction.\n-rcluster: to reduce computations by only examining the top n% (here, 10%) partitioning schemes using the relaxed clustering algorithm (Lanfear et al. 2014).\n--prefix: specifies the prefix for all output files to avoid overwriting the output of previous runs.\n\n\n\nThe main report is a file ending in .merge.iqtree, and the tree is in a file ending in .merge.treefile.\n\n\n\n\n\n\nExercises\n\n\n\n\nLook at the report file data/turtle.merge.iqtree. How many partitions do we have now?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ngrep \"Input data:\" data/turtle.merge.iqtree\n\nInput data: 16 taxa with 7 partitions and 20820 total sites (2.55764% missing data)\n\n\n\n\n\n\nLook at the AIC/AICc/BIC scores. Compared with two previous models, is this model better or worse?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ngrep -A 10 \"List of best-fit models per partition\" data/turtle.merge.iqtree\n\nList of best-fit models per partition:\n\n  ID  Model                  LogL         AIC      w-AIC        AICc     w-AICc         BIC      w-BIC\n   1  TPM3+F+I+G4      -33463.275   66942.550 + 3.38e-316   66942.577 + 5.45e-317   66995.241 + 2.19e-316\n   2  TIM3+F+I+G4      -28588.305   57194.610 + 3.38e-316   57194.643 + 5.45e-317   57254.076 + 2.19e-316\n   3  GTR+F+I+G4       -19434.040   38890.081 + 3.38e-316   38890.158 + 5.45e-317   38957.582 + 2.19e-316\n   4  TIM2e+I+G4        -6224.893   12461.787 + 3.38e-316   12461.874 + 5.45e-317   12491.026 + 2.19e-316\n   5  TIM2+F+G4        -17553.560   35123.120 + 3.38e-316   35123.156 + 5.45e-317   35173.507 + 2.19e-316\n   6  TVMe+I+G4         -6727.848   13469.695 + 3.38e-316   13469.809 + 5.45e-317   13504.000 + 2.19e-316\n   7  TIM+F+G4          -3743.955    7503.910 + 3.38e-316    7504.155 + 5.45e-317    7539.045 + 2.19e-316\n\n\n\n\n\n\nVisualize the tree in data/turtle.merge.treefile. What relationship among three trees does this tree support? What is the ultrafast bootstrap support (%) for the relevant clade?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\n\ntree <- read.tree(here(\"data\", \"turtle.merge.treefile\"))\n\nggtree(tree) +\n    geom_tiplab() +\n    xlim(0, 0.4) +\n    geom_nodelab(hjust = 1.3, vjust = -0.4)\n\n\n\n\nThe tree supports the hypothesis A, which positions turtles as a sister group to birds and crocodiles. The relevant clade has a bootstrap support of 99%.\n\n\n\n\nDoes this tree agree with the published tree (Chiari et al. 2012)?\n\n\n\n\n\n\n\nSolution\n\n\n\n\n\nYes. Both trees agree on the “A” hypothesis, i.e., (Turtle, (Bird, Crocodile))."
  },
  {
    "objectID": "phylogeny_inference_ml.html#references",
    "href": "phylogeny_inference_ml.html#references",
    "title": "4  Maximum likelihood-based phylogeny inference",
    "section": "References",
    "text": "References\n\n\n\n\nChernomor, Olga, Arndt Von Haeseler, and Bui Quang Minh. 2016. “Terrace Aware Data Structure for Phylogenomic Inference from Supermatrices.” Systematic Biology 65 (6): 997–1008.\n\n\nChiari, Ylenia, Vincent Cahais, Nicolas Galtier, and Frédéric Delsuc. 2012. “Phylogenomic Analyses Support the Position of Turtles as the Sister Group of Birds and Crocodiles (Archosauria).” Bmc Biology 10: 1–15.\n\n\nLanfear, Robert, Brett Calcott, Simon YW Ho, and Stephane Guindon. 2012. “PartitionFinder: Combined Selection of Partitioning Schemes and Substitution Models for Phylogenetic Analyses.” Molecular Biology and Evolution 29 (6): 1695–1701.\n\n\nLanfear, Robert, Brett Calcott, David Kainer, Christoph Mayer, and Alexandros Stamatakis. 2014. “Selecting Optimal Partitioning Schemes for Phylogenomic Datasets.” BMC Evolutionary Biology 14: 1–14.\n\n\nMinh, Bui Quang, Minh Anh Thi Nguyen, and Arndt Von Haeseler. 2013. “Ultrafast Approximation for Phylogenetic Bootstrap.” Molecular Biology and Evolution 30 (5): 1188–95.\n\n\nMinh, Bui Quang, Heiko A Schmidt, Olga Chernomor, Dominik Schrempf, Michael D Woodhams, Arndt Von Haeseler, and Robert Lanfear. 2020. “IQ-TREE 2: New Models and Efficient Methods for Phylogenetic Inference in the Genomic Era.” Molecular Biology and Evolution 37 (5): 1530–34."
  },
  {
    "objectID": "gene_genome_duplication.html",
    "href": "gene_genome_duplication.html",
    "title": "5  Analysis of gene and genome duplication",
    "section": "",
    "text": "TBA."
  }
]